0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NBUF         10  
0156 #define NINODE       50  
0157 #define NDEV         10  
0158 #define ROOTDEV       1  
0159 #define MAXARG       32  
0160 #define LOGSIZE      10  
0161 
0162 
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #ifndef __ASSEMBLER__
0211 
0212 static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
0213 static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
0214 
0215 #endif
0216 
0217 #define V2P(a) (((uint) (a)) - KERNBASE)
0218 #define P2V(a) (((void *) (a)) + KERNBASE)
0219 
0220 #define V2P_WO(x) ((x) - KERNBASE)    
0221 #define P2V_WO(x) ((x) + KERNBASE)    
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct spinlock;
0257 struct stat;
0258 struct superblock;
0259 
0260 
0261 void            binit(void);
0262 struct buf*     bread(uint, uint);
0263 void            brelse(struct buf*);
0264 void            bwrite(struct buf*);
0265 
0266 
0267 void            consoleinit(void);
0268 void            cprintf(char*, ...);
0269 void            consoleintr(int(*)(void));
0270 void            panic(char*) __attribute__((noreturn));
0271 
0272 
0273 int             exec(char*, char**);
0274 
0275 
0276 struct file*    filealloc(void);
0277 void            fileclose(struct file*);
0278 struct file*    filedup(struct file*);
0279 void            fileinit(void);
0280 int             fileread(struct file*, char*, int n);
0281 int             filestat(struct file*, struct stat*);
0282 int             filewrite(struct file*, char*, int n);
0283 
0284 
0285 void            readsb(int dev, struct superblock *sb);
0286 int             dirlink(struct inode*, char*, uint);
0287 struct inode*   dirlookup(struct inode*, char*, uint*);
0288 struct inode*   ialloc(uint, short);
0289 struct inode*   idup(struct inode*);
0290 void            iinit(void);
0291 void            ilock(struct inode*);
0292 void            iput(struct inode*);
0293 void            iunlock(struct inode*);
0294 void            iunlockput(struct inode*);
0295 void            iupdate(struct inode*);
0296 int             namecmp(const char*, const char*);
0297 struct inode*   namei(char*);
0298 struct inode*   nameiparent(char*, char*);
0299 int             readi(struct inode*, char*, uint, uint);
0300 void            stati(struct inode*, struct stat*);
0301 int             writei(struct inode*, char*, uint, uint);
0302 
0303 
0304 void            ideinit(void);
0305 void            ideintr(void);
0306 void            iderw(struct buf*);
0307 
0308 
0309 void            ioapicenable(int irq, int cpu);
0310 extern uchar    ioapicid;
0311 void            ioapicinit(void);
0312 
0313 
0314 char*           kalloc(void);
0315 void            kfree(char*);
0316 void            kinit1(void*, void*);
0317 void            kinit2(void*, void*);
0318 
0319 
0320 void            kbdintr(void);
0321 
0322 
0323 int             cpunum(void);
0324 extern volatile uint*    lapic;
0325 void            lapiceoi(void);
0326 void            lapicinit(void);
0327 void            lapicstartap(uchar, uint);
0328 void            microdelay(int);
0329 
0330 
0331 void            initlog(void);
0332 void            log_write(struct buf*);
0333 void            begin_trans();
0334 void            commit_trans();
0335 
0336 
0337 extern int      ismp;
0338 int             mpbcpu(void);
0339 void            mpinit(void);
0340 void            mpstartthem(void);
0341 
0342 
0343 void            picenable(int);
0344 void            picinit(void);
0345 
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 struct proc*    copyproc(struct proc*);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 void            pinit(void);
0364 void            procdump(void);
0365 void            scheduler(void) __attribute__((noreturn));
0366 void            sched(void);
0367 void            sleep(void*, struct spinlock*);
0368 void            userinit(void);
0369 int             wait(void);
0370 void            wakeup(void*);
0371 void            yield(void);
0372 
0373 
0374 void            swtch(struct context**, struct context*);
0375 
0376 
0377 void            acquire(struct spinlock*);
0378 void            getcallerpcs(void*, uint*);
0379 int             holding(struct spinlock*);
0380 void            initlock(struct spinlock*, char*);
0381 void            release(struct spinlock*);
0382 void            pushcli(void);
0383 void            popcli(void);
0384 
0385 
0386 int             memcmp(const void*, const void*, uint);
0387 void*           memmove(void*, const void*, uint);
0388 void*           memset(void*, int, uint);
0389 char*           safestrcpy(char*, const char*, int);
0390 int             strlen(const char*);
0391 int             strncmp(const char*, const char*, uint);
0392 char*           strncpy(char*, const char*, int);
0393 
0394 
0395 int             argint(int, int*);
0396 int             argptr(int, char**, int);
0397 int             argstr(int, char**);
0398 int             fetchint(uint, int*);
0399 int             fetchstr(uint, char**);
0400 void            syscall(void);
0401 
0402 
0403 void            timerinit(void);
0404 
0405 
0406 void            idtinit(void);
0407 extern uint     ticks;
0408 void            tvinit(void);
0409 extern struct spinlock tickslock;
0410 
0411 
0412 void            uartinit(void);
0413 void            uartintr(void);
0414 void            uartputc(int);
0415 
0416 
0417 void            seginit(void);
0418 void            kvmalloc(void);
0419 void            vmenable(void);
0420 pde_t*          setupkvm(void);
0421 char*           uva2ka(pde_t*, char*);
0422 int             allocuvm(pde_t*, uint, uint);
0423 int             deallocuvm(pde_t*, uint, uint);
0424 void            freevm(pde_t*);
0425 void            inituvm(pde_t*, char*, uint);
0426 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0427 pde_t*          copyuvm(pde_t*, uint);
0428 void            switchuvm(struct proc*);
0429 void            switchkvm(void);
0430 int             copyout(pde_t*, uint, void*, uint);
0431 void            clearpteu(pde_t *pgdir, char *uva);
0432 
0433 
0434 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0435 
0436 
0437 
0438 
0439 
0440 
0441 
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 #define SEG_KCODE 1  
0742 #define SEG_KDATA 2  
0743 #define SEG_KCPU  3  
0744 #define SEG_UCODE 4  
0745 #define SEG_UDATA 5  
0746 #define SEG_TSS   6  
0747 
0748 
0749 
0750 #ifndef __ASSEMBLER__
0751 
0752 struct segdesc {
0753   uint lim_15_0 : 16;  
0754   uint base_15_0 : 16; 
0755   uint base_23_16 : 8; 
0756   uint type : 4;       
0757   uint s : 1;          
0758   uint dpl : 2;        
0759   uint p : 1;          
0760   uint lim_19_16 : 4;  
0761   uint avl : 1;        
0762   uint rsv1 : 1;       
0763   uint db : 1;         
0764   uint g : 1;          
0765   uint base_31_24 : 8; 
0766 };
0767 
0768 
0769 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0770 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0771   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0772   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0773 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0774 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0775   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0776   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0777 #endif
0778 
0779 #define DPL_USER    0x3     
0780 
0781 
0782 #define STA_X       0x8     
0783 #define STA_E       0x4     
0784 #define STA_C       0x4     
0785 #define STA_W       0x2     
0786 #define STA_R       0x2     
0787 #define STA_A       0x1     
0788 
0789 
0790 #define STS_T16A    0x1     
0791 #define STS_LDT     0x2     
0792 #define STS_T16B    0x3     
0793 #define STS_CG16    0x4     
0794 #define STS_TG      0x5     
0795 #define STS_IG16    0x6     
0796 #define STS_TG16    0x7     
0797 #define STS_T32A    0x9     
0798 #define STS_T32B    0xB     
0799 #define STS_CG32    0xC     
0800 #define STS_IG32    0xE     
0801 #define STS_TG32    0xF     
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0813 
0814 
0815 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0816 
0817 
0818 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0819 
0820 
0821 #define NPDENTRIES      1024    
0822 #define NPTENTRIES      1024    
0823 #define PGSIZE          4096    
0824 
0825 #define PGSHIFT         12      
0826 #define PTXSHIFT        12      
0827 #define PDXSHIFT        22      
0828 
0829 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0830 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0831 
0832 
0833 #define PTE_P           0x001   
0834 #define PTE_W           0x002   
0835 #define PTE_U           0x004   
0836 #define PTE_PWT         0x008   
0837 #define PTE_PCD         0x010   
0838 #define PTE_A           0x020   
0839 #define PTE_D           0x040   
0840 #define PTE_PS          0x080   
0841 #define PTE_MBZ         0x180   
0842 
0843 
0844 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0845 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0846 
0847 #ifndef __ASSEMBLER__
0848 typedef uint pte_t;
0849 
0850 
0851 struct taskstate {
0852   uint link;         
0853   uint esp0;         
0854   ushort ss0;        
0855   ushort padding1;
0856   uint *esp1;
0857   ushort ss1;
0858   ushort padding2;
0859   uint *esp2;
0860   ushort ss2;
0861   ushort padding3;
0862   void *cr3;         
0863   uint *eip;         
0864   uint eflags;
0865   uint eax;          
0866   uint ecx;
0867   uint edx;
0868   uint ebx;
0869   uint *esp;
0870   uint *ebp;
0871   uint esi;
0872   uint edi;
0873   ushort es;         
0874   ushort padding4;
0875   ushort cs;
0876   ushort padding5;
0877   ushort ss;
0878   ushort padding6;
0879   ushort ds;
0880   ushort padding7;
0881   ushort fs;
0882   ushort padding8;
0883   ushort gs;
0884   ushort padding9;
0885   ushort ldt;
0886   ushort padding10;
0887   ushort t;          
0888   ushort iomb;       
0889 };
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 struct gatedesc {
0902   uint off_15_0 : 16;   
0903   uint cs : 16;         
0904   uint args : 5;        
0905   uint rsv1 : 3;        
0906   uint type : 4;        
0907   uint s : 1;           
0908   uint dpl : 2;         
0909   uint p : 1;           
0910   uint off_31_16 : 16;  
0911 };
0912 
0913 
0914 
0915 
0916 
0917 
0918 
0919 
0920 
0921 #define SETGATE(gate, istrap, sel, off, d)                \
0922 {                                                         \
0923   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0924   (gate).cs = (sel);                                      \
0925   (gate).args = 0;                                        \
0926   (gate).rsv1 = 0;                                        \
0927   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0928   (gate).s = 0;                                           \
0929   (gate).dpl = (d);                                       \
0930   (gate).p = 1;                                           \
0931   (gate).off_31_16 = (uint)(off) >> 16;                  \
0932 }
0933 
0934 #endif
0935 
0936 
0937 
0938 
0939 
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 .p2align 2
1023 .text
1024 .globl multiboot_header
1025 multiboot_header:
1026   
1027   
1028   .long magic
1029   .long flags
1030   .long (-magic-flags)
1031 
1032 
1033 
1034 
1035 .globl _start
1036 _start = V2P_WO(entry)
1037 
1038 
1039 .globl entry
1040 entry:
1041   
1042   movl    %cr4, %eax
1043   orl     $(CR4_PSE), %eax
1044   movl    %eax, %cr4
1045   
1046   movl    $(V2P_WO(entrypgdir)), %eax
1047   movl    %eax, %cr3
1048   
1049   movl    %cr0, %eax
1050   orl     $(CR0_PG|CR0_WP), %eax
1051   movl    %eax, %cr0
1052 
1053   
1054   movl $(stack + KSTACKSIZE), %esp
1055 
1056   
1057   
1058   
1059   
1060   mov $main, %eax
1061   jmp *%eax
1062 
1063 .comm stack, KSTACKSIZE
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 .code16
1124 .globl start
1125 start:
1126   cli
1127 
1128   xorw    %ax,%ax
1129   movw    %ax,%ds
1130   movw    %ax,%es
1131   movw    %ax,%ss
1132 
1133   lgdt    gdtdesc
1134   movl    %cr0, %eax
1135   orl     $CR0_PE, %eax
1136   movl    %eax, %cr0
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150   ljmpl    $(SEG_KCODE<<3), $(start32)
1151 
1152 .code32
1153 start32:
1154   movw    $(SEG_KDATA<<3), %ax
1155   movw    %ax, %ds
1156   movw    %ax, %es
1157   movw    %ax, %ss
1158   movw    $0, %ax
1159   movw    %ax, %fs
1160   movw    %ax, %gs
1161 
1162   
1163   movl    %cr4, %eax
1164   orl     $(CR4_PSE), %eax
1165   movl    %eax, %cr4
1166   
1167   movl    (start-12), %eax
1168   movl    %eax, %cr3
1169   
1170   movl    %cr0, %eax
1171   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1172   movl    %eax, %cr0
1173 
1174   
1175   movl    (start-4), %esp
1176   
1177   call	 *(start-8)
1178 
1179   movw    $0x8a00, %ax
1180   movw    %ax, %dx
1181   outw    %ax, %dx
1182   movw    $0x8ae0, %ax
1183   outw    %ax, %dx
1184 spin:
1185   jmp     spin
1186 
1187 .p2align 2
1188 gdt:
1189   SEG_NULLASM
1190   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1191   SEG_ASM(STA_W, 0, 0xffffffff)
1192 
1193 
1194 gdtdesc:
1195   .word   (gdtdesc - gdt - 1)
1196   .long   gdt
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();
1223   seginit();       
1224   cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
1225   picinit();       
1226   ioapicinit();    
1227   consoleinit();   
1228   uartinit();      
1229   pinit();         
1230   tvinit();        
1231   binit();         
1232   fileinit();      
1233   iinit();         
1234   ideinit();       
1235   if(!ismp)
1236     timerinit();   
1237   startothers();   
1238   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1239   userinit();      
1240   
1241   mpmain();
1242 }
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 static void
1252 mpenter(void)
1253 {
1254   switchkvm();
1255   seginit();
1256   lapicinit();
1257   mpmain();
1258 }
1259 
1260 
1261 static void
1262 mpmain(void)
1263 {
1264   cprintf("cpu%d: starting\n", cpu->id);
1265   idtinit();       
1266   xchg(&cpu->started, 1); 
1267   scheduler();     
1268 }
1269 
1270 pde_t entrypgdir[];  
1271 
1272 
1273 static void
1274 startothers(void)
1275 {
1276   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1277   uchar *code;
1278   struct cpu *c;
1279   char *stack;
1280 
1281   
1282   
1283   
1284   code = p2v(0x7000);
1285   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1286 
1287   for(c = cpus; c < cpus+ncpu; c++){
1288     if(c == cpus+cpunum())  
1289       continue;
1290 
1291     
1292     
1293     
1294     stack = kalloc();
1295     *(void**)(code-4) = stack + KSTACKSIZE;
1296     *(void**)(code-8) = mpenter;
1297     *(int**)(code-12) = (void *) v2p(entrypgdir);
1298 
1299     lapicstartap(c->id, v2p(code));
1300     
1301     while(c->started == 0)
1302       ;
1303   }
1304 }
1305 
1306 
1307 
1308 
1309 
1310 __attribute__((__aligned__(PGSIZE)))
1311 pde_t entrypgdir[NPDENTRIES] = {
1312   
1313   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1314   
1315   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1316 };
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 struct spinlock {
1402   uint locked;       
1403 
1404   
1405   char *name;        
1406   struct cpu *cpu;   
1407   uint pcs[10];      
1408                      
1409 };
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 #include "types.h"
1453 #include "defs.h"
1454 #include "param.h"
1455 #include "x86.h"
1456 #include "memlayout.h"
1457 #include "mmu.h"
1458 #include "proc.h"
1459 #include "spinlock.h"
1460 
1461 void
1462 initlock(struct spinlock *lk, char *name)
1463 {
1464   lk->name = name;
1465   lk->locked = 0;
1466   lk->cpu = 0;
1467 }
1468 
1469 
1470 
1471 
1472 
1473 void
1474 acquire(struct spinlock *lk)
1475 {
1476   pushcli(); 
1477   if(holding(lk))
1478     panic("acquire");
1479 
1480   
1481   
1482   
1483   while(xchg(&lk->locked, 1) != 0)
1484     ;
1485 
1486   
1487   lk->cpu = cpu;
1488   getcallerpcs(&lk, lk->pcs);
1489 }
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 void
1502 release(struct spinlock *lk)
1503 {
1504   if(!holding(lk))
1505     panic("release");
1506 
1507   lk->pcs[0] = 0;
1508   lk->cpu = 0;
1509 
1510   
1511   
1512   
1513   
1514   
1515   
1516   
1517   
1518   
1519   xchg(&lk->locked, 0);
1520 
1521   popcli();
1522 }
1523 
1524 
1525 void
1526 getcallerpcs(void *v, uint pcs[])
1527 {
1528   uint *ebp;
1529   int i;
1530 
1531   ebp = (uint*)v - 2;
1532   for(i = 0; i < 10; i++){
1533     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1534       break;
1535     pcs[i] = ebp[1];     
1536     ebp = (uint*)ebp[0]; 
1537   }
1538   for(; i < 10; i++)
1539     pcs[i] = 0;
1540 }
1541 
1542 
1543 int
1544 holding(struct spinlock *lock)
1545 {
1546   return lock->locked && lock->cpu == cpu;
1547 }
1548 
1549 
1550 
1551 
1552 
1553 
1554 void
1555 pushcli(void)
1556 {
1557   int eflags;
1558 
1559   eflags = readeflags();
1560   cli();
1561   if(cpu->ncli++ == 0)
1562     cpu->intena = eflags & FL_IF;
1563 }
1564 
1565 void
1566 popcli(void)
1567 {
1568   if(readeflags()&FL_IF)
1569     panic("popcli - interruptible");
1570   if(--cpu->ncli < 0)
1571     panic("popcli");
1572   if(cpu->ncli == 0 && cpu->intena)
1573     sti();
1574 }
1575 
1576 
1577 
1578 
1579 
1580 
1581 
1582 
1583 
1584 
1585 
1586 
1587 
1588 
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 #include "param.h"
1601 #include "types.h"
1602 #include "defs.h"
1603 #include "x86.h"
1604 #include "memlayout.h"
1605 #include "mmu.h"
1606 #include "proc.h"
1607 #include "elf.h"
1608 
1609 extern char data[];  
1610 pde_t *kpgdir;  
1611 struct segdesc gdt[NSEGS];
1612 
1613 
1614 
1615 void
1616 seginit(void)
1617 {
1618   struct cpu *c;
1619 
1620   
1621   
1622   
1623   
1624   c = &cpus[cpunum()];
1625   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1626   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1627   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1628   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1629 
1630   
1631   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1632 
1633   lgdt(c->gdt, sizeof(c->gdt));
1634   loadgs(SEG_KCPU << 3);
1635 
1636   
1637   cpu = c;
1638   proc = 0;
1639 }
1640 
1641 
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 
1652 
1653 static pte_t *
1654 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1655 {
1656   pde_t *pde;
1657   pte_t *pgtab;
1658 
1659   pde = &pgdir[PDX(va)];
1660   if(*pde & PTE_P){
1661     pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
1662   } else {
1663     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1664       return 0;
1665     
1666     memset(pgtab, 0, PGSIZE);
1667     
1668     
1669     
1670     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
1671   }
1672   return &pgtab[PTX(va)];
1673 }
1674 
1675 
1676 
1677 
1678 static int
1679 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1680 {
1681   char *a, *last;
1682   pte_t *pte;
1683 
1684   a = (char*)PGROUNDDOWN((uint)va);
1685   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1686   for(;;){
1687     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1688       return -1;
1689     if(*pte & PTE_P)
1690       panic("remap");
1691     *pte = pa | perm | PTE_P;
1692     if(a == last)
1693       break;
1694     a += PGSIZE;
1695     pa += PGSIZE;
1696   }
1697   return 0;
1698 }
1699 
1700 
1701 
1702 
1703 
1704 
1705 
1706 
1707 
1708 
1709 
1710 
1711 
1712 
1713 
1714 
1715 
1716 
1717 
1718 
1719 
1720 
1721 
1722 
1723 static struct kmap {
1724   void *virt;
1725   uint phys_start;
1726   uint phys_end;
1727   int perm;
1728 } kmap[] = {
1729  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1730  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1731  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1732  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1733 };
1734 
1735 
1736 pde_t*
1737 setupkvm(void)
1738 {
1739   pde_t *pgdir;
1740   struct kmap *k;
1741 
1742   if((pgdir = (pde_t*)kalloc()) == 0)
1743     return 0;
1744   memset(pgdir, 0, PGSIZE);
1745   if (p2v(PHYSTOP) > (void*)DEVSPACE)
1746     panic("PHYSTOP too high");
1747   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1748     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1749                 (uint)k->phys_start, k->perm) < 0)
1750       return 0;
1751   return pgdir;
1752 }
1753 
1754 
1755 
1756 void
1757 kvmalloc(void)
1758 {
1759   kpgdir = setupkvm();
1760   switchkvm();
1761 }
1762 
1763 
1764 
1765 void
1766 switchkvm(void)
1767 {
1768   lcr3(v2p(kpgdir));   
1769 }
1770 
1771 
1772 void
1773 switchuvm(struct proc *p)
1774 {
1775   pushcli();
1776   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1777   cpu->gdt[SEG_TSS].s = 0;
1778   cpu->ts.ss0 = SEG_KDATA << 3;
1779   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
1780   ltr(SEG_TSS << 3);
1781   if(p->pgdir == 0)
1782     panic("switchuvm: no pgdir");
1783   lcr3(v2p(p->pgdir));  
1784   popcli();
1785 }
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 void
1803 inituvm(pde_t *pgdir, char *init, uint sz)
1804 {
1805   char *mem;
1806 
1807   if(sz >= PGSIZE)
1808     panic("inituvm: more than a page");
1809   mem = kalloc();
1810   memset(mem, 0, PGSIZE);
1811   mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
1812   memmove(mem, init, sz);
1813 }
1814 
1815 
1816 
1817 int
1818 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1819 {
1820   uint i, pa, n;
1821   pte_t *pte;
1822 
1823   if((uint) addr % PGSIZE != 0)
1824     panic("loaduvm: addr must be page aligned");
1825   for(i = 0; i < sz; i += PGSIZE){
1826     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1827       panic("loaduvm: address should exist");
1828     pa = PTE_ADDR(*pte);
1829     if(sz - i < PGSIZE)
1830       n = sz - i;
1831     else
1832       n = PGSIZE;
1833     if(readi(ip, p2v(pa), offset+i, n) != n)
1834       return -1;
1835   }
1836   return 0;
1837 }
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 int
1853 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1854 {
1855   char *mem;
1856   uint a;
1857 
1858   if(newsz >= KERNBASE)
1859     return 0;
1860   if(newsz < oldsz)
1861     return oldsz;
1862 
1863   a = PGROUNDUP(oldsz);
1864   for(; a < newsz; a += PGSIZE){
1865     mem = kalloc();
1866     if(mem == 0){
1867       cprintf("allocuvm out of memory\n");
1868       deallocuvm(pgdir, newsz, oldsz);
1869       return 0;
1870     }
1871     memset(mem, 0, PGSIZE);
1872     mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
1873   }
1874   return newsz;
1875 }
1876 
1877 
1878 
1879 
1880 
1881 int
1882 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1883 {
1884   pte_t *pte;
1885   uint a, pa;
1886 
1887   if(newsz >= oldsz)
1888     return oldsz;
1889 
1890   a = PGROUNDUP(newsz);
1891   for(; a  < oldsz; a += PGSIZE){
1892     pte = walkpgdir(pgdir, (char*)a, 0);
1893     if(!pte)
1894       a += (NPTENTRIES - 1) * PGSIZE;
1895     else if((*pte & PTE_P) != 0){
1896       pa = PTE_ADDR(*pte);
1897       if(pa == 0)
1898         panic("kfree");
1899       char *v = p2v(pa);
1900       kfree(v);
1901       *pte = 0;
1902     }
1903   }
1904   return newsz;
1905 }
1906 
1907 
1908 
1909 void
1910 freevm(pde_t *pgdir)
1911 {
1912   uint i;
1913 
1914   if(pgdir == 0)
1915     panic("freevm: no pgdir");
1916   deallocuvm(pgdir, KERNBASE, 0);
1917   for(i = 0; i < NPDENTRIES; i++){
1918     if(pgdir[i] & PTE_P){
1919       char * v = p2v(PTE_ADDR(pgdir[i]));
1920       kfree(v);
1921     }
1922   }
1923   kfree((char*)pgdir);
1924 }
1925 
1926 
1927 
1928 void
1929 clearpteu(pde_t *pgdir, char *uva)
1930 {
1931   pte_t *pte;
1932 
1933   pte = walkpgdir(pgdir, uva, 0);
1934   if(pte == 0)
1935     panic("clearpteu");
1936   *pte &= ~PTE_U;
1937 }
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 pde_t*
1953 copyuvm(pde_t *pgdir, uint sz)
1954 {
1955   pde_t *d;
1956   pte_t *pte;
1957   uint pa, i, flags;
1958   char *mem;
1959 
1960   if((d = setupkvm()) == 0)
1961     return 0;
1962   for(i = 0; i < sz; i += PGSIZE){
1963     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
1964       panic("copyuvm: pte should exist");
1965     if(!(*pte & PTE_P))
1966       panic("copyuvm: page not present");
1967     pa = PTE_ADDR(*pte);
1968     flags = PTE_FLAGS(*pte);
1969     if((mem = kalloc()) == 0)
1970       goto bad;
1971     memmove(mem, (char*)p2v(pa), PGSIZE);
1972     if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
1973       goto bad;
1974   }
1975   return d;
1976 
1977 bad:
1978   freevm(d);
1979   return 0;
1980 }
1981 
1982 
1983 
1984 
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 char*
2002 uva2ka(pde_t *pgdir, char *uva)
2003 {
2004   pte_t *pte;
2005 
2006   pte = walkpgdir(pgdir, uva, 0);
2007   if((*pte & PTE_P) == 0)
2008     return 0;
2009   if((*pte & PTE_U) == 0)
2010     return 0;
2011   return (char*)p2v(PTE_ADDR(*pte));
2012 }
2013 
2014 
2015 
2016 
2017 int
2018 copyout(pde_t *pgdir, uint va, void *p, uint len)
2019 {
2020   char *buf, *pa0;
2021   uint n, va0;
2022 
2023   buf = (char*)p;
2024   while(len > 0){
2025     va0 = (uint)PGROUNDDOWN(va);
2026     pa0 = uva2ka(pgdir, (char*)va0);
2027     if(pa0 == 0)
2028       return -1;
2029     n = PGSIZE - (va - va0);
2030     if(n > len)
2031       n = len;
2032     memmove(pa0 + (va - va0), buf, n);
2033     len -= n;
2034     buf += n;
2035     va = va0 + PGSIZE;
2036   }
2037   return 0;
2038 }
2039 
2040 
2041 
2042 
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 #define NSEGS     7
2052 
2053 
2054 struct cpu {
2055   uchar id;                    
2056   struct context *scheduler;   
2057   struct taskstate ts;         
2058   struct segdesc gdt[NSEGS];   
2059   volatile uint started;       
2060   int ncli;                    
2061   int intena;                  
2062 
2063   
2064   struct cpu *cpu;
2065   struct proc *proc;           
2066 };
2067 
2068 extern struct cpu cpus[NCPU];
2069 extern int ncpu;
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 extern struct cpu *cpu asm("%gs:0");       
2080 extern struct proc *proc asm("%gs:4");     
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 struct context {
2094   uint edi;
2095   uint esi;
2096   uint ebx;
2097   uint ebp;
2098   uint eip;
2099 };
2100 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2101 
2102 
2103 struct proc {
2104   uint sz;                     
2105   pde_t* pgdir;                
2106   char *kstack;                
2107   enum procstate state;        
2108   volatile int pid;            
2109   struct proc *parent;         
2110   struct trapframe *tf;        
2111   struct context *context;     
2112   void *chan;                  
2113   int killed;                  
2114   struct file *ofile[NOFILE];  
2115   struct inode *cwd;           
2116   char name[16];               
2117 };
2118 
2119 
2120 
2121 
2122 
2123 
2124 
2125 
2126 
2127 
2128 
2129 
2130 
2131 
2132 
2133 
2134 
2135 
2136 
2137 
2138 
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 #include "types.h"
2151 #include "defs.h"
2152 #include "param.h"
2153 #include "memlayout.h"
2154 #include "mmu.h"
2155 #include "x86.h"
2156 #include "proc.h"
2157 #include "spinlock.h"
2158 
2159 struct {
2160   struct spinlock lock;
2161   struct proc proc[NPROC];
2162 } ptable;
2163 
2164 static struct proc *initproc;
2165 
2166 int nextpid = 1;
2167 extern void forkret(void);
2168 extern void trapret(void);
2169 
2170 static void wakeup1(void *chan);
2171 
2172 void
2173 pinit(void)
2174 {
2175   initlock(&ptable.lock, "ptable");
2176 }
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 static struct proc*
2205 allocproc(void)
2206 {
2207   struct proc *p;
2208   char *sp;
2209 
2210   acquire(&ptable.lock);
2211   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2212     if(p->state == UNUSED)
2213       goto found;
2214   release(&ptable.lock);
2215   return 0;
2216 
2217 found:
2218   p->state = EMBRYO;
2219   p->pid = nextpid++;
2220   release(&ptable.lock);
2221 
2222   
2223   if((p->kstack = kalloc()) == 0){
2224     p->state = UNUSED;
2225     return 0;
2226   }
2227   sp = p->kstack + KSTACKSIZE;
2228 
2229   
2230   sp -= sizeof *p->tf;
2231   p->tf = (struct trapframe*)sp;
2232 
2233   
2234   
2235   sp -= 4;
2236   *(uint*)sp = (uint)trapret;
2237 
2238   sp -= sizeof *p->context;
2239   p->context = (struct context*)sp;
2240   memset(p->context, 0, sizeof *p->context);
2241   p->context->eip = (uint)forkret;
2242 
2243   return p;
2244 }
2245 
2246 
2247 
2248 
2249 
2250 
2251 void
2252 userinit(void)
2253 {
2254   struct proc *p;
2255   extern char _binary_initcode_start[], _binary_initcode_size[];
2256 
2257   p = allocproc();
2258   initproc = p;
2259   if((p->pgdir = setupkvm()) == 0)
2260     panic("userinit: out of memory?");
2261   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2262   p->sz = PGSIZE;
2263   memset(p->tf, 0, sizeof(*p->tf));
2264   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2265   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2266   p->tf->es = p->tf->ds;
2267   p->tf->ss = p->tf->ds;
2268   p->tf->eflags = FL_IF;
2269   p->tf->esp = PGSIZE;
2270   p->tf->eip = 0;  
2271 
2272   safestrcpy(p->name, "initcode", sizeof(p->name));
2273   p->cwd = namei("/");
2274 
2275   p->state = RUNNABLE;
2276 }
2277 
2278 
2279 
2280 int
2281 growproc(int n)
2282 {
2283   uint sz;
2284 
2285   sz = proc->sz;
2286   if(n > 0){
2287     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2288       return -1;
2289   } else if(n < 0){
2290     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2291       return -1;
2292   }
2293   proc->sz = sz;
2294   switchuvm(proc);
2295   return 0;
2296 }
2297 
2298 
2299 
2300 
2301 
2302 
2303 int
2304 fork(void)
2305 {
2306   int i, pid;
2307   struct proc *np;
2308 
2309   
2310   if((np = allocproc()) == 0)
2311     return -1;
2312 
2313   
2314   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2315     kfree(np->kstack);
2316     np->kstack = 0;
2317     np->state = UNUSED;
2318     return -1;
2319   }
2320   np->sz = proc->sz;
2321   np->parent = proc;
2322   *np->tf = *proc->tf;
2323 
2324   
2325   np->tf->eax = 0;
2326 
2327   for(i = 0; i < NOFILE; i++)
2328     if(proc->ofile[i])
2329       np->ofile[i] = filedup(proc->ofile[i]);
2330   np->cwd = idup(proc->cwd);
2331 
2332   pid = np->pid;
2333   np->state = RUNNABLE;
2334   safestrcpy(np->name, proc->name, sizeof(proc->name));
2335   return pid;
2336 }
2337 
2338 
2339 
2340 
2341 
2342 
2343 
2344 
2345 
2346 
2347 
2348 
2349 
2350 
2351 
2352 
2353 void
2354 exit(void)
2355 {
2356   struct proc *p;
2357   int fd;
2358 
2359   if(proc == initproc)
2360     panic("init exiting");
2361 
2362   
2363   for(fd = 0; fd < NOFILE; fd++){
2364     if(proc->ofile[fd]){
2365       fileclose(proc->ofile[fd]);
2366       proc->ofile[fd] = 0;
2367     }
2368   }
2369 
2370   iput(proc->cwd);
2371   proc->cwd = 0;
2372 
2373   acquire(&ptable.lock);
2374 
2375   
2376   wakeup1(proc->parent);
2377 
2378   
2379   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2380     if(p->parent == proc){
2381       p->parent = initproc;
2382       if(p->state == ZOMBIE)
2383         wakeup1(initproc);
2384     }
2385   }
2386 
2387   
2388   proc->state = ZOMBIE;
2389   sched();
2390   panic("zombie exit");
2391 }
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 
2401 
2402 int
2403 wait(void)
2404 {
2405   struct proc *p;
2406   int havekids, pid;
2407 
2408   acquire(&ptable.lock);
2409   for(;;){
2410     
2411     havekids = 0;
2412     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2413       if(p->parent != proc)
2414         continue;
2415       havekids = 1;
2416       if(p->state == ZOMBIE){
2417         
2418         pid = p->pid;
2419         kfree(p->kstack);
2420         p->kstack = 0;
2421         freevm(p->pgdir);
2422         p->state = UNUSED;
2423         p->pid = 0;
2424         p->parent = 0;
2425         p->name[0] = 0;
2426         p->killed = 0;
2427         release(&ptable.lock);
2428         return pid;
2429       }
2430     }
2431 
2432     
2433     if(!havekids || proc->killed){
2434       release(&ptable.lock);
2435       return -1;
2436     }
2437 
2438     
2439     sleep(proc, &ptable.lock);  
2440   }
2441 }
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452 
2453 
2454 
2455 
2456 
2457 void
2458 scheduler(void)
2459 {
2460   struct proc *p;
2461 
2462   for(;;){
2463     
2464     sti();
2465 
2466     
2467     acquire(&ptable.lock);
2468     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2469       if(p->state != RUNNABLE)
2470         continue;
2471 
2472       
2473       
2474       
2475       proc = p;
2476       switchuvm(p);
2477       p->state = RUNNING;
2478       swtch(&cpu->scheduler, proc->context); 
2479       switchkvm();
2480 
2481       
2482       
2483       proc = 0;
2484     }
2485     release(&ptable.lock);
2486 
2487   }
2488 }
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 void
2503 sched(void)
2504 {
2505   int intena;
2506 
2507   if(!holding(&ptable.lock))
2508     panic("sched ptable.lock");
2509   if(cpu->ncli != 1)
2510     panic("sched locks");
2511   if(proc->state == RUNNING)
2512     panic("sched running");
2513   if(readeflags()&FL_IF)
2514     panic("sched interruptible");
2515   intena = cpu->intena;
2516   swtch(&proc->context, cpu->scheduler); 
2517   cpu->intena = intena;
2518 }
2519 
2520 
2521 void
2522 yield(void)
2523 {
2524   acquire(&ptable.lock);  
2525   proc->state = RUNNABLE;
2526   sched();
2527   release(&ptable.lock);
2528 }
2529 
2530 
2531 
2532 void
2533 forkret(void)
2534 {
2535   static int first = 1;
2536   
2537   release(&ptable.lock);
2538 
2539   if (first) {
2540     
2541     
2542     
2543     first = 0;
2544     initlog();
2545   }
2546 
2547   
2548 }
2549 
2550 
2551 
2552 void
2553 sleep(void *chan, struct spinlock *lk)
2554 {
2555   if(proc == 0)
2556     panic("sleep");
2557 
2558   if(lk == 0)
2559     panic("sleep without lk");
2560 
2561   
2562   
2563   
2564   
2565   
2566   
2567   if(lk != &ptable.lock){  
2568     acquire(&ptable.lock);  
2569     release(lk);
2570   }
2571 
2572   
2573   proc->chan = chan;
2574   proc->state = SLEEPING;
2575   sched();
2576 
2577   
2578   proc->chan = 0;
2579 
2580   
2581   if(lk != &ptable.lock){  
2582     release(&ptable.lock);
2583     acquire(lk);
2584   }
2585 }
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 static void
2603 wakeup1(void *chan)
2604 {
2605   struct proc *p;
2606 
2607   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2608     if(p->state == SLEEPING && p->chan == chan)
2609       p->state = RUNNABLE;
2610 }
2611 
2612 
2613 void
2614 wakeup(void *chan)
2615 {
2616   acquire(&ptable.lock);
2617   wakeup1(chan);
2618   release(&ptable.lock);
2619 }
2620 
2621 
2622 
2623 
2624 int
2625 kill(int pid)
2626 {
2627   struct proc *p;
2628 
2629   acquire(&ptable.lock);
2630   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2631     if(p->pid == pid){
2632       p->killed = 1;
2633       
2634       if(p->state == SLEEPING)
2635         p->state = RUNNABLE;
2636       release(&ptable.lock);
2637       return 0;
2638     }
2639   }
2640   release(&ptable.lock);
2641   return -1;
2642 }
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 void
2654 procdump(void)
2655 {
2656   static char *states[] = {
2657   [UNUSED]    "unused",
2658   [EMBRYO]    "embryo",
2659   [SLEEPING]  "sleep ",
2660   [RUNNABLE]  "runble",
2661   [RUNNING]   "run   ",
2662   [ZOMBIE]    "zombie"
2663   };
2664   int i;
2665   struct proc *p;
2666   char *state;
2667   uint pc[10];
2668 
2669   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2670     if(p->state == UNUSED)
2671       continue;
2672     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
2673       state = states[p->state];
2674     else
2675       state = "???";
2676     cprintf("%d %s %s", p->pid, state, p->name);
2677     if(p->state == SLEEPING){
2678       getcallerpcs((uint*)p->context->ebp+2, pc);
2679       for(i=0; i<10 && pc[i] != 0; i++)
2680         cprintf(" %p", pc[i]);
2681     }
2682     cprintf("\n");
2683   }
2684 }
2685 
2686 
2687 
2688 
2689 
2690 
2691 
2692 
2693 
2694 
2695 
2696 
2697 
2698 
2699 
2700 
2701 
2702 
2703 
2704 
2705 
2706 
2707 .globl swtch
2708 swtch:
2709   movl 4(%esp), %eax 
2710   movl 8(%esp), %edx 
2711 
2712   
2713   pushl %ebp
2714   pushl %ebx
2715   pushl %esi
2716   pushl %edi
2717 
2718   
2719   movl %esp, (%eax)
2720   movl %edx, %esp
2721 
2722   
2723   popl %edi
2724   popl %esi
2725   popl %ebx
2726   popl %ebp
2727   ret
2728 
2729 
2730 
2731 
2732 
2733 
2734 
2735 
2736 
2737 
2738 
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 
2753 
2754 #include "types.h"
2755 #include "defs.h"
2756 #include "param.h"
2757 #include "memlayout.h"
2758 #include "mmu.h"
2759 #include "spinlock.h"
2760 
2761 void freerange(void *vstart, void *vend);
2762 extern char end[]; 
2763 
2764 struct run {
2765   struct run *next;
2766 };
2767 
2768 struct {
2769   struct spinlock lock;
2770   int use_lock;
2771   struct run *freelist;
2772 } kmem;
2773 
2774 
2775 
2776 
2777 
2778 
2779 void
2780 kinit1(void *vstart, void *vend)
2781 {
2782   initlock(&kmem.lock, "kmem");
2783   kmem.use_lock = 0;
2784   freerange(vstart, vend);
2785 }
2786 
2787 void
2788 kinit2(void *vstart, void *vend)
2789 {
2790   freerange(vstart, vend);
2791   kmem.use_lock = 1;
2792 }
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 void
2801 freerange(void *vstart, void *vend)
2802 {
2803   char *p;
2804   p = (char*)PGROUNDUP((uint)vstart);
2805   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
2806     kfree(p);
2807 }
2808 
2809 
2810 
2811 
2812 
2813 
2814 void
2815 kfree(char *v)
2816 {
2817   struct run *r;
2818 
2819   if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
2820     panic("kfree");
2821 
2822   
2823   memset(v, 1, PGSIZE);
2824 
2825   if(kmem.use_lock)
2826     acquire(&kmem.lock);
2827   r = (struct run*)v;
2828   r->next = kmem.freelist;
2829   kmem.freelist = r;
2830   if(kmem.use_lock)
2831     release(&kmem.lock);
2832 }
2833 
2834 
2835 
2836 
2837 char*
2838 kalloc(void)
2839 {
2840   struct run *r;
2841 
2842   if(kmem.use_lock)
2843     acquire(&kmem.lock);
2844   r = kmem.freelist;
2845   if(r)
2846     kmem.freelist = r->next;
2847   if(kmem.use_lock)
2848     release(&kmem.lock);
2849   return (char*)r;
2850 }
2851 
2852 
2853 
2854 
2855 
2856 
2857 
2858 
2859 
2860 
2861 
2862 
2863 
2864 
2865 
2866 
2867 
2868 
2869 
2870 
2871 
2872 
2873 
2874 
2875 
2876 
2877 
2878 
2879 
2880 
2881 
2882 
2883 
2884 
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 
2903 #define T_DIVIDE         0      
2904 #define T_DEBUG          1      
2905 #define T_NMI            2      
2906 #define T_BRKPT          3      
2907 #define T_OFLOW          4      
2908 #define T_BOUND          5      
2909 #define T_ILLOP          6      
2910 #define T_DEVICE         7      
2911 #define T_DBLFLT         8      
2912 
2913 #define T_TSS           10      
2914 #define T_SEGNP         11      
2915 #define T_STACK         12      
2916 #define T_GPFLT         13      
2917 #define T_PGFLT         14      
2918 
2919 #define T_FPERR         16      
2920 #define T_ALIGN         17      
2921 #define T_MCHK          18      
2922 #define T_SIMDERR       19      
2923 
2924 
2925 
2926 #define T_SYSCALL       64      
2927 #define T_DEFAULT      500      
2928 
2929 #define T_IRQ0          32      
2930 
2931 #define IRQ_TIMER        0
2932 #define IRQ_KBD          1
2933 #define IRQ_COM1         4
2934 #define IRQ_IDE         14
2935 #define IRQ_ERROR       19
2936 #define IRQ_SPURIOUS    31
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 #!/usr/bin/perl -w
2951 
2952 # Generate vectors.S, the trap/interrupt entry points.
2953 # There has to be one entry point per interrupt number
2954 # since otherwise there's no way for trap() to discover
2955 # the interrupt number.
2956 
2957 print "# generated by vectors.pl - do not edit\n";
2958 print "# handlers\n";
2959 print ".globl alltraps\n";
2960 for(my $i = 0; $i < 256; $i++){
2961     print ".globl vector$i\n";
2962     print "vector$i:\n";
2963     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
2964         print "  pushl \$0\n";
2965     }
2966     print "  pushl \$$i\n";
2967     print "  jmp alltraps\n";
2968 }
2969 
2970 print "\n# vector table\n";
2971 print ".data\n";
2972 print ".globl vectors\n";
2973 print "vectors:\n";
2974 for(my $i = 0; $i < 256; $i++){
2975     print "  .long vector$i\n";
2976 }
2977 
2978 # sample output:
2979 #   # handlers
2980 #   .globl alltraps
2981 #   .globl vector0
2982 #   vector0:
2983 #     pushl $0
2984 #     pushl $0
2985 #     jmp alltraps
2986 #   ...
2987 #
2988 #   # vector table
2989 #   .data
2990 #   .globl vectors
2991 #   vectors:
2992 #     .long vector0
2993 #     .long vector1
2994 #     .long vector2
2995 #   ...
2996 
2997 
2998 
2999 
3000 
3001 
3002   
3003 .globl alltraps
3004 alltraps:
3005   
3006   pushl %ds
3007   pushl %es
3008   pushl %fs
3009   pushl %gs
3010   pushal
3011 
3012   
3013   movw $(SEG_KDATA<<3), %ax
3014   movw %ax, %ds
3015   movw %ax, %es
3016   movw $(SEG_KCPU<<3), %ax
3017   movw %ax, %fs
3018   movw %ax, %gs
3019 
3020   
3021   pushl %esp
3022   call trap
3023   addl $4, %esp
3024 
3025   
3026 .globl trapret
3027 trapret:
3028   popal
3029   popl %gs
3030   popl %fs
3031   popl %es
3032   popl %ds
3033   addl $0x8, %esp  
3034   iret
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 #include "types.h"
3051 #include "defs.h"
3052 #include "param.h"
3053 #include "memlayout.h"
3054 #include "mmu.h"
3055 #include "proc.h"
3056 #include "x86.h"
3057 #include "traps.h"
3058 #include "spinlock.h"
3059 
3060 
3061 struct gatedesc idt[256];
3062 extern uint vectors[];  
3063 struct spinlock tickslock;
3064 uint ticks;
3065 
3066 void
3067 tvinit(void)
3068 {
3069   int i;
3070 
3071   for(i = 0; i < 256; i++)
3072     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3073   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3074 
3075   initlock(&tickslock, "time");
3076 }
3077 
3078 void
3079 idtinit(void)
3080 {
3081   lidt(idt, sizeof(idt));
3082 }
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 void
3101 trap(struct trapframe *tf)
3102 {
3103   if(tf->trapno == T_SYSCALL){
3104     if(proc->killed)
3105       exit();
3106     proc->tf = tf;
3107     syscall();
3108     if(proc->killed)
3109       exit();
3110     return;
3111   }
3112 
3113   switch(tf->trapno){
3114   case T_IRQ0 + IRQ_TIMER:
3115     if(cpu->id == 0){
3116       acquire(&tickslock);
3117       ticks++;
3118       wakeup(&ticks);
3119       release(&tickslock);
3120     }
3121     lapiceoi();
3122     break;
3123   case T_IRQ0 + IRQ_IDE:
3124     ideintr();
3125     lapiceoi();
3126     break;
3127   case T_IRQ0 + IRQ_IDE+1:
3128     
3129     break;
3130   case T_IRQ0 + IRQ_KBD:
3131     kbdintr();
3132     lapiceoi();
3133     break;
3134   case T_IRQ0 + IRQ_COM1:
3135     uartintr();
3136     lapiceoi();
3137     break;
3138   case T_IRQ0 + 7:
3139   case T_IRQ0 + IRQ_SPURIOUS:
3140     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3141             cpu->id, tf->cs, tf->eip);
3142     lapiceoi();
3143     break;
3144 
3145 
3146 
3147 
3148 
3149 
3150   default:
3151     if(proc == 0 || (tf->cs&3) == 0){
3152       
3153       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3154               tf->trapno, cpu->id, tf->eip, rcr2());
3155       panic("trap");
3156     }
3157     
3158     cprintf("pid %d %s: trap %d err %d on cpu %d "
3159             "eip 0x%x addr 0x%x--kill proc\n",
3160             proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
3161             rcr2());
3162     proc->killed = 1;
3163   }
3164 
3165   
3166   
3167   
3168   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3169     exit();
3170 
3171   
3172   
3173   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
3174     yield();
3175 
3176   
3177   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3178     exit();
3179 }
3180 
3181 
3182 
3183 
3184 
3185 
3186 
3187 
3188 
3189 
3190 
3191 
3192 
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 #define SYS_fork    1
3202 #define SYS_exit    2
3203 #define SYS_wait    3
3204 #define SYS_pipe    4
3205 #define SYS_read    5
3206 #define SYS_kill    6
3207 #define SYS_exec    7
3208 #define SYS_fstat   8
3209 #define SYS_chdir   9
3210 #define SYS_dup    10
3211 #define SYS_getpid 11
3212 #define SYS_sbrk   12
3213 #define SYS_sleep  13
3214 #define SYS_uptime 14
3215 #define SYS_open   15
3216 #define SYS_write  16
3217 #define SYS_mknod  17
3218 #define SYS_unlink 18
3219 #define SYS_link   19
3220 #define SYS_mkdir  20
3221 #define SYS_close  21
3222 #define SYS_getmysize 22
3223 #define SYS_getkernelstartaddr 23
3224 #define SYS_getkernelendaddr 24
3225 #define SYS_getkernelvariaddr 25
3226 #define SYS_getsystemcalladdr 26
3227 #define SYS_setpriority 26
3228 
3229 
3230 
3231 
3232 
3233 
3234 
3235 
3236 
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #include "types.h"
3251 #include "defs.h"
3252 #include "param.h"
3253 #include "memlayout.h"
3254 #include "mmu.h"
3255 #include "proc.h"
3256 #include "x86.h"
3257 #include "syscall.h"
3258 
3259 
3260 
3261 
3262 
3263 
3264 
3265 
3266 int
3267 fetchint(uint addr, int *ip)
3268 {
3269   if(addr >= proc->sz || addr+4 > proc->sz)
3270     return -1;
3271   *ip = *(int*)(addr);
3272   return 0;
3273 }
3274 
3275 
3276 
3277 
3278 int
3279 fetchstr(uint addr, char **pp)
3280 {
3281   char *s, *ep;
3282 
3283   if(addr >= proc->sz)
3284     return -1;
3285   *pp = (char*)addr;
3286   ep = (char*)proc->sz;
3287   for(s = *pp; s < ep; s++)
3288     if(*s == 0)
3289       return s - *pp;
3290   return -1;
3291 }
3292 
3293 
3294 int
3295 argint(int n, int *ip)
3296 {
3297   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3298 }
3299 
3300 
3301 
3302 
3303 int
3304 argptr(int n, char **pp, int size)
3305 {
3306   int i;
3307 
3308   if(argint(n, &i) < 0)
3309     return -1;
3310   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
3311     return -1;
3312   *pp = (char*)i;
3313   return 0;
3314 }
3315 
3316 
3317 
3318 
3319 
3320 int
3321 argstr(int n, char **pp)
3322 {
3323   int addr;
3324   if(argint(n, &addr) < 0)
3325     return -1;
3326   return fetchstr(addr, pp);
3327 }
3328 
3329 extern int sys_chdir(void);
3330 extern int sys_close(void);
3331 extern int sys_dup(void);
3332 extern int sys_exec(void);
3333 extern int sys_exit(void);
3334 extern int sys_fork(void);
3335 extern int sys_fstat(void);
3336 extern int sys_getpid(void);
3337 extern int sys_kill(void);
3338 extern int sys_link(void);
3339 extern int sys_mkdir(void);
3340 extern int sys_mknod(void);
3341 extern int sys_open(void);
3342 extern int sys_pipe(void);
3343 extern int sys_read(void);
3344 extern int sys_sbrk(void);
3345 extern int sys_sleep(void);
3346 extern int sys_unlink(void);
3347 extern int sys_wait(void);
3348 extern int sys_write(void);
3349 extern int sys_uptime(void);
3350 extern int sys_getmysize(void);
3351 extern int sys_getkernelstartaddr(void);
3352 extern int sys_getkernelendaddr(void);
3353 extern int sys_getkernelvariaddr(void);
3354 extern int sys_getsystemcalladdr(void);
3355 extern int sys_setpriority(void);
3356 
3357 static int (*syscalls[])(void) = {
3358 [SYS_fork]    sys_fork,
3359 [SYS_exit]    sys_exit,
3360 [SYS_wait]    sys_wait,
3361 [SYS_pipe]    sys_pipe,
3362 [SYS_read]    sys_read,
3363 [SYS_kill]    sys_kill,
3364 [SYS_exec]    sys_exec,
3365 [SYS_fstat]   sys_fstat,
3366 [SYS_chdir]   sys_chdir,
3367 [SYS_dup]     sys_dup,
3368 [SYS_getpid]  sys_getpid,
3369 [SYS_sbrk]    sys_sbrk,
3370 [SYS_sleep]   sys_sleep,
3371 [SYS_uptime]  sys_uptime,
3372 [SYS_open]    sys_open,
3373 [SYS_write]   sys_write,
3374 [SYS_mknod]   sys_mknod,
3375 [SYS_unlink]  sys_unlink,
3376 [SYS_link]    sys_link,
3377 [SYS_mkdir]   sys_mkdir,
3378 [SYS_close]   sys_close,
3379 [SYS_getmysize] sys_getmysize,
3380 [SYS_getkernelstartaddr] sys_getkernelstartaddr,
3381 [SYS_getkernelendaddr] sys_getkernelendaddr,
3382 [SYS_getkernelvariaddr] sys_getkernelvariaddr,
3383 [SYS_getsystemcalladdr] sys_getsystemcalladdr,
3384 [SYS_setpriority] sys_setpriority,
3385 };
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 void
3401 syscall(void)
3402 {
3403   int num;
3404 
3405   num = proc->tf->eax;
3406   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3407     proc->tf->eax = syscalls[num]();
3408   } else {
3409     cprintf("%d %s: unknown sys call %d\n",
3410             proc->pid, proc->name, num);
3411     proc->tf->eax = -1;
3412   }
3413 }
3414 
3415 
3416 
3417 
3418 
3419 
3420 
3421 
3422 
3423 
3424 
3425 
3426 
3427 
3428 
3429 
3430 
3431 
3432 
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 #include "types.h"
3451 #include "x86.h"
3452 #include "defs.h"
3453 #include "param.h"
3454 #include "memlayout.h"
3455 #include "mmu.h"
3456 #include "proc.h"
3457 
3458 int
3459 sys_fork(void)
3460 {
3461   return fork();
3462 }
3463 
3464 int
3465 sys_exit(void)
3466 {
3467   exit();
3468   return 0;  
3469 }
3470 
3471 int
3472 sys_wait(void)
3473 {
3474   return wait();
3475 }
3476 
3477 int
3478 sys_kill(void)
3479 {
3480   int pid;
3481 
3482   if(argint(0, &pid) < 0)
3483     return -1;
3484   return kill(pid);
3485 }
3486 
3487 int
3488 sys_getpid(void)
3489 {
3490   return proc->pid;
3491 }
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 int
3501 sys_sbrk(void)
3502 {
3503   int addr;
3504   int n;
3505 
3506   if(argint(0, &n) < 0)
3507     return -1;
3508   addr = proc->sz;
3509   if(growproc(n) < 0)
3510     return -1;
3511   return addr;
3512 }
3513 
3514 int
3515 sys_sleep(void)
3516 {
3517   int n;
3518   uint ticks0;
3519 
3520   if(argint(0, &n) < 0)
3521     return -1;
3522   acquire(&tickslock);
3523   ticks0 = ticks;
3524   while(ticks - ticks0 < n){
3525     if(proc->killed){
3526       release(&tickslock);
3527       return -1;
3528     }
3529     sleep(&ticks, &tickslock);
3530   }
3531   release(&tickslock);
3532   return 0;
3533 }
3534 
3535 
3536 
3537 int
3538 sys_uptime(void)
3539 {
3540   uint xticks;
3541 
3542   acquire(&tickslock);
3543   xticks = ticks;
3544   release(&tickslock);
3545   return xticks;
3546 }
3547 
3548 
3549 
3550 int
3551 sys_getmysize(void)
3552 {
3553   int addr;
3554   addr = proc->sz;
3555   return addr;
3556 }
3557 
3558 uint
3559 sys_getkernelstartaddr(void)
3560 {
3561   return KERNBASE;
3562 }
3563 
3564 uint
3565 sys_getkernelendaddr(void)
3566 {
3567   return KERNBASE+PHYSTOP;
3568 }
3569 
3570 uint
3571 sys_getkernelvariaddr(void)
3572 {
3573   int a=1;
3574   uint send=(uint)&a;
3575   return send;
3576 }
3577 
3578 uint
3579 sys_getsystemcalladdr(void)
3580 {
3581   return (uint)&sys_fork;
3582 }
3583 
3584 int sys_setpriority(void)
3585 {
3586   int priority;
3587   argint(0, &priority);
3588   return priority;
3589 }
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 struct buf {
3601   int flags;
3602   uint dev;
3603   uint sector;
3604   struct buf *prev; 
3605   struct buf *next;
3606   struct buf *qnext; 
3607   uchar data[512];
3608 };
3609 #define B_BUSY  0x1  
3610 #define B_VALID 0x2  
3611 #define B_DIRTY 0x4  
3612 
3613 
3614 
3615 
3616 
3617 
3618 
3619 
3620 
3621 
3622 
3623 
3624 
3625 
3626 
3627 
3628 
3629 
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 #define O_RDONLY  0x000
3651 #define O_WRONLY  0x001
3652 #define O_RDWR    0x002
3653 #define O_CREATE  0x200
3654 
3655 
3656 
3657 
3658 
3659 
3660 
3661 
3662 
3663 
3664 
3665 
3666 
3667 
3668 
3669 
3670 
3671 
3672 
3673 
3674 
3675 
3676 
3677 
3678 
3679 
3680 
3681 
3682 
3683 
3684 
3685 
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 #define T_DIR  1   
3701 #define T_FILE 2   
3702 #define T_DEV  3   
3703 
3704 struct stat {
3705   short type;  
3706   int dev;     
3707   uint ino;    
3708   short nlink; 
3709   uint size;   
3710 };
3711 
3712 
3713 
3714 
3715 
3716 
3717 
3718 
3719 
3720 
3721 
3722 
3723 
3724 
3725 
3726 
3727 
3728 
3729 
3730 
3731 
3732 
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 
3751 
3752 
3753 
3754 
3755 
3756 
3757 
3758 
3759 
3760 #define ROOTINO 1  
3761 #define BSIZE 512  
3762 
3763 
3764 struct superblock {
3765   uint size;         
3766   uint nblocks;      
3767   uint ninodes;      
3768   uint nlog;         
3769 };
3770 
3771 #define NDIRECT 12
3772 #define NINDIRECT (BSIZE / sizeof(uint))
3773 #define MAXFILE (NDIRECT + NINDIRECT)
3774 
3775 
3776 struct dinode {
3777   short type;           
3778   short major;          
3779   short minor;          
3780   short nlink;          
3781   uint size;            
3782   uint addrs[NDIRECT+1];   
3783 };
3784 
3785 
3786 #define IPB           (BSIZE / sizeof(struct dinode))
3787 
3788 
3789 #define IBLOCK(i)     ((i) / IPB + 2)
3790 
3791 
3792 #define BPB           (BSIZE*8)
3793 
3794 
3795 #define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
3796 
3797 
3798 #define DIRSIZ 14
3799 
3800 struct dirent {
3801   ushort inum;
3802   char name[DIRSIZ];
3803 };
3804 
3805 
3806 
3807 
3808 
3809 
3810 
3811 
3812 
3813 
3814 
3815 
3816 
3817 
3818 
3819 
3820 
3821 
3822 
3823 
3824 
3825 
3826 
3827 
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 struct file {
3851   enum { FD_NONE, FD_PIPE, FD_INODE } type;
3852   int ref; 
3853   char readable;
3854   char writable;
3855   struct pipe *pipe;
3856   struct inode *ip;
3857   uint off;
3858 };
3859 
3860 
3861 
3862 struct inode {
3863   uint dev;           
3864   uint inum;          
3865   int ref;            
3866   int flags;          
3867 
3868   short type;         
3869   short major;
3870   short minor;
3871   short nlink;
3872   uint size;
3873   uint addrs[NDIRECT+1];
3874 };
3875 #define I_BUSY 0x1
3876 #define I_VALID 0x2
3877 
3878 
3879 
3880 struct devsw {
3881   int (*read)(struct inode*, char*, int);
3882   int (*write)(struct inode*, char*, int);
3883 };
3884 
3885 extern struct devsw devsw[];
3886 
3887 #define CONSOLE 1
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 
3901 
3902 #include "types.h"
3903 #include "defs.h"
3904 #include "param.h"
3905 #include "memlayout.h"
3906 #include "mmu.h"
3907 #include "proc.h"
3908 #include "x86.h"
3909 #include "traps.h"
3910 #include "spinlock.h"
3911 #include "buf.h"
3912 
3913 #define IDE_BSY       0x80
3914 #define IDE_DRDY      0x40
3915 #define IDE_DF        0x20
3916 #define IDE_ERR       0x01
3917 
3918 #define IDE_CMD_READ  0x20
3919 #define IDE_CMD_WRITE 0x30
3920 
3921 
3922 
3923 
3924 
3925 static struct spinlock idelock;
3926 static struct buf *idequeue;
3927 
3928 static int havedisk1;
3929 static void idestart(struct buf*);
3930 
3931 
3932 static int
3933 idewait(int checkerr)
3934 {
3935   int r;
3936 
3937   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
3938     ;
3939   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
3940     return -1;
3941   return 0;
3942 }
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 void
3951 ideinit(void)
3952 {
3953   int i;
3954 
3955   initlock(&idelock, "ide");
3956   picenable(IRQ_IDE);
3957   ioapicenable(IRQ_IDE, ncpu - 1);
3958   idewait(0);
3959 
3960   
3961   outb(0x1f6, 0xe0 | (1<<4));
3962   for(i=0; i<1000; i++){
3963     if(inb(0x1f7) != 0){
3964       havedisk1 = 1;
3965       break;
3966     }
3967   }
3968 
3969   
3970   outb(0x1f6, 0xe0 | (0<<4));
3971 }
3972 
3973 
3974 static void
3975 idestart(struct buf *b)
3976 {
3977   if(b == 0)
3978     panic("idestart");
3979 
3980   idewait(0);
3981   outb(0x3f6, 0);  
3982   outb(0x1f2, 1);  
3983   outb(0x1f3, b->sector & 0xff);
3984   outb(0x1f4, (b->sector >> 8) & 0xff);
3985   outb(0x1f5, (b->sector >> 16) & 0xff);
3986   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f));
3987   if(b->flags & B_DIRTY){
3988     outb(0x1f7, IDE_CMD_WRITE);
3989     outsl(0x1f0, b->data, 512/4);
3990   } else {
3991     outb(0x1f7, IDE_CMD_READ);
3992   }
3993 }
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 void
4002 ideintr(void)
4003 {
4004   struct buf *b;
4005 
4006   
4007   acquire(&idelock);
4008   if((b = idequeue) == 0){
4009     release(&idelock);
4010     
4011     return;
4012   }
4013   idequeue = b->qnext;
4014 
4015   
4016   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4017     insl(0x1f0, b->data, 512/4);
4018 
4019   
4020   b->flags |= B_VALID;
4021   b->flags &= ~B_DIRTY;
4022   wakeup(b);
4023 
4024   
4025   if(idequeue != 0)
4026     idestart(idequeue);
4027 
4028   release(&idelock);
4029 }
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 
4051 
4052 
4053 void
4054 iderw(struct buf *b)
4055 {
4056   struct buf **pp;
4057 
4058   if(!(b->flags & B_BUSY))
4059     panic("iderw: buf not busy");
4060   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4061     panic("iderw: nothing to do");
4062   if(b->dev != 0 && !havedisk1)
4063     panic("iderw: ide disk 1 not present");
4064 
4065   acquire(&idelock);  
4066 
4067   
4068   b->qnext = 0;
4069   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4070     ;
4071   *pp = b;
4072 
4073   
4074   if(idequeue == b)
4075     idestart(b);
4076 
4077   
4078   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4079     sleep(b, &idelock);
4080   }
4081 
4082   release(&idelock);
4083 }
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 
4101 
4102 
4103 
4104 
4105 
4106 
4107 
4108 
4109 
4110 
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 #include "types.h"
4123 #include "defs.h"
4124 #include "param.h"
4125 #include "spinlock.h"
4126 #include "buf.h"
4127 
4128 struct {
4129   struct spinlock lock;
4130   struct buf buf[NBUF];
4131 
4132   
4133   
4134   struct buf head;
4135 } bcache;
4136 
4137 void
4138 binit(void)
4139 {
4140   struct buf *b;
4141 
4142   initlock(&bcache.lock, "bcache");
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150   
4151   bcache.head.prev = &bcache.head;
4152   bcache.head.next = &bcache.head;
4153   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4154     b->next = bcache.head.next;
4155     b->prev = &bcache.head;
4156     b->dev = -1;
4157     bcache.head.next->prev = b;
4158     bcache.head.next = b;
4159   }
4160 }
4161 
4162 
4163 
4164 
4165 static struct buf*
4166 bget(uint dev, uint sector)
4167 {
4168   struct buf *b;
4169 
4170   acquire(&bcache.lock);
4171 
4172  loop:
4173   
4174   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4175     if(b->dev == dev && b->sector == sector){
4176       if(!(b->flags & B_BUSY)){
4177         b->flags |= B_BUSY;
4178         release(&bcache.lock);
4179         return b;
4180       }
4181       sleep(b, &bcache.lock);
4182       goto loop;
4183     }
4184   }
4185 
4186   
4187   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4188     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
4189       b->dev = dev;
4190       b->sector = sector;
4191       b->flags = B_BUSY;
4192       release(&bcache.lock);
4193       return b;
4194     }
4195   }
4196   panic("bget: no buffers");
4197 }
4198 
4199 
4200 
4201 struct buf*
4202 bread(uint dev, uint sector)
4203 {
4204   struct buf *b;
4205 
4206   b = bget(dev, sector);
4207   if(!(b->flags & B_VALID))
4208     iderw(b);
4209   return b;
4210 }
4211 
4212 
4213 void
4214 bwrite(struct buf *b)
4215 {
4216   if((b->flags & B_BUSY) == 0)
4217     panic("bwrite");
4218   b->flags |= B_DIRTY;
4219   iderw(b);
4220 }
4221 
4222 
4223 
4224 void
4225 brelse(struct buf *b)
4226 {
4227   if((b->flags & B_BUSY) == 0)
4228     panic("brelse");
4229 
4230   acquire(&bcache.lock);
4231 
4232   b->next->prev = b->prev;
4233   b->prev->next = b->next;
4234   b->next = bcache.head.next;
4235   b->prev = &bcache.head;
4236   bcache.head.next->prev = b;
4237   bcache.head.next = b;
4238 
4239   b->flags &= ~B_BUSY;
4240   wakeup(b);
4241 
4242   release(&bcache.lock);
4243 }
4244 
4245 
4246 
4247 
4248 
4249 
4250 #include "types.h"
4251 #include "defs.h"
4252 #include "param.h"
4253 #include "spinlock.h"
4254 #include "fs.h"
4255 #include "buf.h"
4256 
4257 
4258 
4259 
4260 
4261 
4262 
4263 
4264 
4265 
4266 
4267 
4268 
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 
4284 
4285 struct logheader {
4286   int n;
4287   int sector[LOGSIZE];
4288 };
4289 
4290 struct log {
4291   struct spinlock lock;
4292   int start;
4293   int size;
4294   int busy; 
4295   int dev;
4296   struct logheader lh;
4297 };
4298 
4299 
4300 struct log log;
4301 
4302 static void recover_from_log(void);
4303 
4304 void
4305 initlog(void)
4306 {
4307   if (sizeof(struct logheader) >= BSIZE)
4308     panic("initlog: too big logheader");
4309 
4310   struct superblock sb;
4311   initlock(&log.lock, "log");
4312   readsb(ROOTDEV, &sb);
4313   log.start = sb.size - sb.nlog;
4314   log.size = sb.nlog;
4315   log.dev = ROOTDEV;
4316   recover_from_log();
4317 }
4318 
4319 
4320 static void
4321 install_trans(void)
4322 {
4323   int tail;
4324 
4325   for (tail = 0; tail < log.lh.n; tail++) {
4326     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4327     struct buf *dbuf = bread(log.dev, log.lh.sector[tail]); 
4328     memmove(dbuf->data, lbuf->data, BSIZE);  
4329     bwrite(dbuf);  
4330     brelse(lbuf);
4331     brelse(dbuf);
4332   }
4333 }
4334 
4335 
4336 static void
4337 read_head(void)
4338 {
4339   struct buf *buf = bread(log.dev, log.start);
4340   struct logheader *lh = (struct logheader *) (buf->data);
4341   int i;
4342   log.lh.n = lh->n;
4343   for (i = 0; i < log.lh.n; i++) {
4344     log.lh.sector[i] = lh->sector[i];
4345   }
4346   brelse(buf);
4347 }
4348 
4349 
4350 
4351 
4352 
4353 static void
4354 write_head(void)
4355 {
4356   struct buf *buf = bread(log.dev, log.start);
4357   struct logheader *hb = (struct logheader *) (buf->data);
4358   int i;
4359   hb->n = log.lh.n;
4360   for (i = 0; i < log.lh.n; i++) {
4361     hb->sector[i] = log.lh.sector[i];
4362   }
4363   bwrite(buf);
4364   brelse(buf);
4365 }
4366 
4367 static void
4368 recover_from_log(void)
4369 {
4370   read_head();
4371   install_trans(); 
4372   log.lh.n = 0;
4373   write_head(); 
4374 }
4375 
4376 void
4377 begin_trans(void)
4378 {
4379   acquire(&log.lock);
4380   while (log.busy) {
4381     sleep(&log, &log.lock);
4382   }
4383   log.busy = 1;
4384   release(&log.lock);
4385 }
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 void
4401 commit_trans(void)
4402 {
4403   if (log.lh.n > 0) {
4404     write_head();    
4405     install_trans(); 
4406     log.lh.n = 0;
4407     write_head();    
4408   }
4409 
4410   acquire(&log.lock);
4411   log.busy = 0;
4412   wakeup(&log);
4413   release(&log.lock);
4414 }
4415 
4416 
4417 
4418 
4419 
4420 
4421 
4422 
4423 
4424 void
4425 log_write(struct buf *b)
4426 {
4427   int i;
4428 
4429   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4430     panic("too big a transaction");
4431   if (!log.busy)
4432     panic("write outside of trans");
4433 
4434   for (i = 0; i < log.lh.n; i++) {
4435     if (log.lh.sector[i] == b->sector)   
4436       break;
4437   }
4438   log.lh.sector[i] = b->sector;
4439   struct buf *lbuf = bread(b->dev, log.start+i+1);
4440   memmove(lbuf->data, b->data, BSIZE);
4441   bwrite(lbuf);
4442   brelse(lbuf);
4443   if (i == log.lh.n)
4444     log.lh.n++;
4445   b->flags |= B_DIRTY; 
4446 }
4447 
4448 
4449 
4450 
4451 
4452 
4453 
4454 
4455 
4456 
4457 
4458 
4459 
4460 
4461 
4462 
4463 
4464 
4465 
4466 
4467 
4468 
4469 
4470 
4471 
4472 
4473 
4474 
4475 
4476 
4477 
4478 
4479 
4480 
4481 
4482 
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 #include "types.h"
4512 #include "defs.h"
4513 #include "param.h"
4514 #include "stat.h"
4515 #include "mmu.h"
4516 #include "proc.h"
4517 #include "spinlock.h"
4518 #include "buf.h"
4519 #include "fs.h"
4520 #include "file.h"
4521 
4522 #define min(a, b) ((a) < (b) ? (a) : (b))
4523 static void itrunc(struct inode*);
4524 
4525 
4526 void
4527 readsb(int dev, struct superblock *sb)
4528 {
4529   struct buf *bp;
4530 
4531   bp = bread(dev, 1);
4532   memmove(sb, bp->data, sizeof(*sb));
4533   brelse(bp);
4534 }
4535 
4536 
4537 static void
4538 bzero(int dev, int bno)
4539 {
4540   struct buf *bp;
4541 
4542   bp = bread(dev, bno);
4543   memset(bp->data, 0, BSIZE);
4544   log_write(bp);
4545   brelse(bp);
4546 }
4547 
4548 
4549 
4550 
4551 
4552 
4553 static uint
4554 balloc(uint dev)
4555 {
4556   int b, bi, m;
4557   struct buf *bp;
4558   struct superblock sb;
4559 
4560   bp = 0;
4561   readsb(dev, &sb);
4562   for(b = 0; b < sb.size; b += BPB){
4563     bp = bread(dev, BBLOCK(b, sb.ninodes));
4564     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
4565       m = 1 << (bi % 8);
4566       if((bp->data[bi/8] & m) == 0){  
4567         bp->data[bi/8] |= m;  
4568         log_write(bp);
4569         brelse(bp);
4570         bzero(dev, b + bi);
4571         return b + bi;
4572       }
4573     }
4574     brelse(bp);
4575   }
4576   panic("balloc: out of blocks");
4577 }
4578 
4579 
4580 static void
4581 bfree(int dev, uint b)
4582 {
4583   struct buf *bp;
4584   struct superblock sb;
4585   int bi, m;
4586 
4587   readsb(dev, &sb);
4588   bp = bread(dev, BBLOCK(b, sb.ninodes));
4589   bi = b % BPB;
4590   m = 1 << (bi % 8);
4591   if((bp->data[bi/8] & m) == 0)
4592     panic("freeing free block");
4593   bp->data[bi/8] &= ~m;
4594   log_write(bp);
4595   brelse(bp);
4596 }
4597 
4598 
4599 
4600 
4601 
4602 
4603 
4604 
4605 
4606 
4607 
4608 
4609 
4610 
4611 
4612 
4613 
4614 
4615 
4616 
4617 
4618 
4619 
4620 
4621 
4622 
4623 
4624 
4625 
4626 
4627 
4628 
4629 
4630 
4631 
4632 
4633 
4634 
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 
4656 
4657 
4658 
4659 
4660 
4661 
4662 struct {
4663   struct spinlock lock;
4664   struct inode inode[NINODE];
4665 } icache;
4666 
4667 void
4668 iinit(void)
4669 {
4670   initlock(&icache.lock, "icache");
4671 }
4672 
4673 static struct inode* iget(uint dev, uint inum);
4674 
4675 
4676 
4677 
4678 
4679 
4680 
4681 
4682 
4683 
4684 
4685 
4686 
4687 
4688 
4689 
4690 
4691 
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 
4701 
4702 struct inode*
4703 ialloc(uint dev, short type)
4704 {
4705   int inum;
4706   struct buf *bp;
4707   struct dinode *dip;
4708   struct superblock sb;
4709 
4710   readsb(dev, &sb);
4711 
4712   for(inum = 1; inum < sb.ninodes; inum++){
4713     bp = bread(dev, IBLOCK(inum));
4714     dip = (struct dinode*)bp->data + inum%IPB;
4715     if(dip->type == 0){  
4716       memset(dip, 0, sizeof(*dip));
4717       dip->type = type;
4718       log_write(bp);   
4719       brelse(bp);
4720       return iget(dev, inum);
4721     }
4722     brelse(bp);
4723   }
4724   panic("ialloc: no inodes");
4725 }
4726 
4727 
4728 void
4729 iupdate(struct inode *ip)
4730 {
4731   struct buf *bp;
4732   struct dinode *dip;
4733 
4734   bp = bread(ip->dev, IBLOCK(ip->inum));
4735   dip = (struct dinode*)bp->data + ip->inum%IPB;
4736   dip->type = ip->type;
4737   dip->major = ip->major;
4738   dip->minor = ip->minor;
4739   dip->nlink = ip->nlink;
4740   dip->size = ip->size;
4741   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
4742   log_write(bp);
4743   brelse(bp);
4744 }
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 
4753 static struct inode*
4754 iget(uint dev, uint inum)
4755 {
4756   struct inode *ip, *empty;
4757 
4758   acquire(&icache.lock);
4759 
4760   
4761   empty = 0;
4762   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
4763     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
4764       ip->ref++;
4765       release(&icache.lock);
4766       return ip;
4767     }
4768     if(empty == 0 && ip->ref == 0)    
4769       empty = ip;
4770   }
4771 
4772   
4773   if(empty == 0)
4774     panic("iget: no inodes");
4775 
4776   ip = empty;
4777   ip->dev = dev;
4778   ip->inum = inum;
4779   ip->ref = 1;
4780   ip->flags = 0;
4781   release(&icache.lock);
4782 
4783   return ip;
4784 }
4785 
4786 
4787 
4788 struct inode*
4789 idup(struct inode *ip)
4790 {
4791   acquire(&icache.lock);
4792   ip->ref++;
4793   release(&icache.lock);
4794   return ip;
4795 }
4796 
4797 
4798 
4799 
4800 
4801 
4802 void
4803 ilock(struct inode *ip)
4804 {
4805   struct buf *bp;
4806   struct dinode *dip;
4807 
4808   if(ip == 0 || ip->ref < 1)
4809     panic("ilock");
4810 
4811   acquire(&icache.lock);
4812   while(ip->flags & I_BUSY)
4813     sleep(ip, &icache.lock);
4814   ip->flags |= I_BUSY;
4815   release(&icache.lock);
4816 
4817   if(!(ip->flags & I_VALID)){
4818     bp = bread(ip->dev, IBLOCK(ip->inum));
4819     dip = (struct dinode*)bp->data + ip->inum%IPB;
4820     ip->type = dip->type;
4821     ip->major = dip->major;
4822     ip->minor = dip->minor;
4823     ip->nlink = dip->nlink;
4824     ip->size = dip->size;
4825     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
4826     brelse(bp);
4827     ip->flags |= I_VALID;
4828     if(ip->type == 0)
4829       panic("ilock: no type");
4830   }
4831 }
4832 
4833 
4834 void
4835 iunlock(struct inode *ip)
4836 {
4837   if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
4838     panic("iunlock");
4839 
4840   acquire(&icache.lock);
4841   ip->flags &= ~I_BUSY;
4842   wakeup(ip);
4843   release(&icache.lock);
4844 }
4845 
4846 
4847 
4848 
4849 
4850 
4851 
4852 
4853 
4854 
4855 void
4856 iput(struct inode *ip)
4857 {
4858   acquire(&icache.lock);
4859   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
4860     
4861     if(ip->flags & I_BUSY)
4862       panic("iput busy");
4863     ip->flags |= I_BUSY;
4864     release(&icache.lock);
4865     itrunc(ip);
4866     ip->type = 0;
4867     iupdate(ip);
4868     acquire(&icache.lock);
4869     ip->flags = 0;
4870     wakeup(ip);
4871   }
4872   ip->ref--;
4873   release(&icache.lock);
4874 }
4875 
4876 
4877 void
4878 iunlockput(struct inode *ip)
4879 {
4880   iunlock(ip);
4881   iput(ip);
4882 }
4883 
4884 
4885 
4886 
4887 
4888 
4889 
4890 
4891 
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 
4903 
4904 
4905 
4906 
4907 
4908 
4909 static uint
4910 bmap(struct inode *ip, uint bn)
4911 {
4912   uint addr, *a;
4913   struct buf *bp;
4914 
4915   if(bn < NDIRECT){
4916     if((addr = ip->addrs[bn]) == 0)
4917       ip->addrs[bn] = addr = balloc(ip->dev);
4918     return addr;
4919   }
4920   bn -= NDIRECT;
4921 
4922   if(bn < NINDIRECT){
4923     
4924     if((addr = ip->addrs[NDIRECT]) == 0)
4925       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
4926     bp = bread(ip->dev, addr);
4927     a = (uint*)bp->data;
4928     if((addr = a[bn]) == 0){
4929       a[bn] = addr = balloc(ip->dev);
4930       log_write(bp);
4931     }
4932     brelse(bp);
4933     return addr;
4934   }
4935 
4936   panic("bmap: out of range");
4937 }
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 
4953 
4954 
4955 static void
4956 itrunc(struct inode *ip)
4957 {
4958   int i, j;
4959   struct buf *bp;
4960   uint *a;
4961 
4962   for(i = 0; i < NDIRECT; i++){
4963     if(ip->addrs[i]){
4964       bfree(ip->dev, ip->addrs[i]);
4965       ip->addrs[i] = 0;
4966     }
4967   }
4968 
4969   if(ip->addrs[NDIRECT]){
4970     bp = bread(ip->dev, ip->addrs[NDIRECT]);
4971     a = (uint*)bp->data;
4972     for(j = 0; j < NINDIRECT; j++){
4973       if(a[j])
4974         bfree(ip->dev, a[j]);
4975     }
4976     brelse(bp);
4977     bfree(ip->dev, ip->addrs[NDIRECT]);
4978     ip->addrs[NDIRECT] = 0;
4979   }
4980 
4981   ip->size = 0;
4982   iupdate(ip);
4983 }
4984 
4985 
4986 void
4987 stati(struct inode *ip, struct stat *st)
4988 {
4989   st->dev = ip->dev;
4990   st->ino = ip->inum;
4991   st->type = ip->type;
4992   st->nlink = ip->nlink;
4993   st->size = ip->size;
4994 }
4995 
4996 
4997 
4998 
4999 
5000 
5001 int
5002 readi(struct inode *ip, char *dst, uint off, uint n)
5003 {
5004   uint tot, m;
5005   struct buf *bp;
5006 
5007   if(ip->type == T_DEV){
5008     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5009       return -1;
5010     return devsw[ip->major].read(ip, dst, n);
5011   }
5012 
5013   if(off > ip->size || off + n < off)
5014     return -1;
5015   if(off + n > ip->size)
5016     n = ip->size - off;
5017 
5018   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5019     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5020     m = min(n - tot, BSIZE - off%BSIZE);
5021     memmove(dst, bp->data + off%BSIZE, m);
5022     brelse(bp);
5023   }
5024   return n;
5025 }
5026 
5027 
5028 
5029 
5030 
5031 
5032 
5033 
5034 
5035 
5036 
5037 
5038 
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 int
5052 writei(struct inode *ip, char *src, uint off, uint n)
5053 {
5054   uint tot, m;
5055   struct buf *bp;
5056 
5057   if(ip->type == T_DEV){
5058     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5059       return -1;
5060     return devsw[ip->major].write(ip, src, n);
5061   }
5062 
5063   if(off > ip->size || off + n < off)
5064     return -1;
5065   if(off + n > MAXFILE*BSIZE)
5066     return -1;
5067 
5068   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5069     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5070     m = min(n - tot, BSIZE - off%BSIZE);
5071     memmove(bp->data + off%BSIZE, src, m);
5072     log_write(bp);
5073     brelse(bp);
5074   }
5075 
5076   if(n > 0 && off > ip->size){
5077     ip->size = off;
5078     iupdate(ip);
5079   }
5080   return n;
5081 }
5082 
5083 
5084 
5085 
5086 
5087 
5088 
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 
5102 int
5103 namecmp(const char *s, const char *t)
5104 {
5105   return strncmp(s, t, DIRSIZ);
5106 }
5107 
5108 
5109 
5110 struct inode*
5111 dirlookup(struct inode *dp, char *name, uint *poff)
5112 {
5113   uint off, inum;
5114   struct dirent de;
5115 
5116   if(dp->type != T_DIR)
5117     panic("dirlookup not DIR");
5118 
5119   for(off = 0; off < dp->size; off += sizeof(de)){
5120     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5121       panic("dirlink read");
5122     if(de.inum == 0)
5123       continue;
5124     if(namecmp(name, de.name) == 0){
5125       
5126       if(poff)
5127         *poff = off;
5128       inum = de.inum;
5129       return iget(dp->dev, inum);
5130     }
5131   }
5132 
5133   return 0;
5134 }
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 int
5152 dirlink(struct inode *dp, char *name, uint inum)
5153 {
5154   int off;
5155   struct dirent de;
5156   struct inode *ip;
5157 
5158   
5159   if((ip = dirlookup(dp, name, 0)) != 0){
5160     iput(ip);
5161     return -1;
5162   }
5163 
5164   
5165   for(off = 0; off < dp->size; off += sizeof(de)){
5166     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5167       panic("dirlink read");
5168     if(de.inum == 0)
5169       break;
5170   }
5171 
5172   strncpy(de.name, name, DIRSIZ);
5173   de.inum = inum;
5174   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5175     panic("dirlink");
5176 
5177   return 0;
5178 }
5179 
5180 
5181 
5182 
5183 
5184 
5185 
5186 
5187 
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 
5204 
5205 
5206 
5207 
5208 
5209 
5210 
5211 
5212 
5213 
5214 static char*
5215 skipelem(char *path, char *name)
5216 {
5217   char *s;
5218   int len;
5219 
5220   while(*path == '/')
5221     path++;
5222   if(*path == 0)
5223     return 0;
5224   s = path;
5225   while(*path != '/' && *path != 0)
5226     path++;
5227   len = path - s;
5228   if(len >= DIRSIZ)
5229     memmove(name, s, DIRSIZ);
5230   else {
5231     memmove(name, s, len);
5232     name[len] = 0;
5233   }
5234   while(*path == '/')
5235     path++;
5236   return path;
5237 }
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 static struct inode*
5254 namex(char *path, int nameiparent, char *name)
5255 {
5256   struct inode *ip, *next;
5257 
5258   if(*path == '/')
5259     ip = iget(ROOTDEV, ROOTINO);
5260   else
5261     ip = idup(proc->cwd);
5262 
5263   while((path = skipelem(path, name)) != 0){
5264     ilock(ip);
5265     if(ip->type != T_DIR){
5266       iunlockput(ip);
5267       return 0;
5268     }
5269     if(nameiparent && *path == '\0'){
5270       
5271       iunlock(ip);
5272       return ip;
5273     }
5274     if((next = dirlookup(ip, name, 0)) == 0){
5275       iunlockput(ip);
5276       return 0;
5277     }
5278     iunlockput(ip);
5279     ip = next;
5280   }
5281   if(nameiparent){
5282     iput(ip);
5283     return 0;
5284   }
5285   return ip;
5286 }
5287 
5288 struct inode*
5289 namei(char *path)
5290 {
5291   char name[DIRSIZ];
5292   return namex(path, 0, name);
5293 }
5294 
5295 struct inode*
5296 nameiparent(char *path, char *name)
5297 {
5298   return namex(path, 1, name);
5299 }
5300 
5301 
5302 
5303 
5304 #include "types.h"
5305 #include "defs.h"
5306 #include "param.h"
5307 #include "fs.h"
5308 #include "file.h"
5309 #include "spinlock.h"
5310 
5311 struct devsw devsw[NDEV];
5312 struct {
5313   struct spinlock lock;
5314   struct file file[NFILE];
5315 } ftable;
5316 
5317 void
5318 fileinit(void)
5319 {
5320   initlock(&ftable.lock, "ftable");
5321 }
5322 
5323 
5324 struct file*
5325 filealloc(void)
5326 {
5327   struct file *f;
5328 
5329   acquire(&ftable.lock);
5330   for(f = ftable.file; f < ftable.file + NFILE; f++){
5331     if(f->ref == 0){
5332       f->ref = 1;
5333       release(&ftable.lock);
5334       return f;
5335     }
5336   }
5337   release(&ftable.lock);
5338   return 0;
5339 }
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 struct file*
5352 filedup(struct file *f)
5353 {
5354   acquire(&ftable.lock);
5355   if(f->ref < 1)
5356     panic("filedup");
5357   f->ref++;
5358   release(&ftable.lock);
5359   return f;
5360 }
5361 
5362 
5363 void
5364 fileclose(struct file *f)
5365 {
5366   struct file ff;
5367 
5368   acquire(&ftable.lock);
5369   if(f->ref < 1)
5370     panic("fileclose");
5371   if(--f->ref > 0){
5372     release(&ftable.lock);
5373     return;
5374   }
5375   ff = *f;
5376   f->ref = 0;
5377   f->type = FD_NONE;
5378   release(&ftable.lock);
5379 
5380   if(ff.type == FD_PIPE)
5381     pipeclose(ff.pipe, ff.writable);
5382   else if(ff.type == FD_INODE){
5383     begin_trans();
5384     iput(ff.ip);
5385     commit_trans();
5386   }
5387 }
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 int
5402 filestat(struct file *f, struct stat *st)
5403 {
5404   if(f->type == FD_INODE){
5405     ilock(f->ip);
5406     stati(f->ip, st);
5407     iunlock(f->ip);
5408     return 0;
5409   }
5410   return -1;
5411 }
5412 
5413 
5414 int
5415 fileread(struct file *f, char *addr, int n)
5416 {
5417   int r;
5418 
5419   if(f->readable == 0)
5420     return -1;
5421   if(f->type == FD_PIPE)
5422     return piperead(f->pipe, addr, n);
5423   if(f->type == FD_INODE){
5424     ilock(f->ip);
5425     if((r = readi(f->ip, addr, f->off, n)) > 0)
5426       f->off += r;
5427     iunlock(f->ip);
5428     return r;
5429   }
5430   panic("fileread");
5431 }
5432 
5433 
5434 
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 int
5452 filewrite(struct file *f, char *addr, int n)
5453 {
5454   int r;
5455 
5456   if(f->writable == 0)
5457     return -1;
5458   if(f->type == FD_PIPE)
5459     return pipewrite(f->pipe, addr, n);
5460   if(f->type == FD_INODE){
5461     
5462     
5463     
5464     
5465     
5466     
5467     int max = ((LOGSIZE-1-1-2) / 2) * 512;
5468     int i = 0;
5469     while(i < n){
5470       int n1 = n - i;
5471       if(n1 > max)
5472         n1 = max;
5473 
5474       begin_trans();
5475       ilock(f->ip);
5476       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
5477         f->off += r;
5478       iunlock(f->ip);
5479       commit_trans();
5480 
5481       if(r < 0)
5482         break;
5483       if(r != n1)
5484         panic("short filewrite");
5485       i += r;
5486     }
5487     return i == n ? n : -1;
5488   }
5489   panic("filewrite");
5490 }
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 #include "types.h"
5507 #include "defs.h"
5508 #include "param.h"
5509 #include "stat.h"
5510 #include "mmu.h"
5511 #include "proc.h"
5512 #include "fs.h"
5513 #include "file.h"
5514 #include "fcntl.h"
5515 
5516 
5517 
5518 static int
5519 argfd(int n, int *pfd, struct file **pf)
5520 {
5521   int fd;
5522   struct file *f;
5523 
5524   if(argint(n, &fd) < 0)
5525     return -1;
5526   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
5527     return -1;
5528   if(pfd)
5529     *pfd = fd;
5530   if(pf)
5531     *pf = f;
5532   return 0;
5533 }
5534 
5535 
5536 
5537 static int
5538 fdalloc(struct file *f)
5539 {
5540   int fd;
5541 
5542   for(fd = 0; fd < NOFILE; fd++){
5543     if(proc->ofile[fd] == 0){
5544       proc->ofile[fd] = f;
5545       return fd;
5546     }
5547   }
5548   return -1;
5549 }
5550 int
5551 sys_dup(void)
5552 {
5553   struct file *f;
5554   int fd;
5555 
5556   if(argfd(0, 0, &f) < 0)
5557     return -1;
5558   if((fd=fdalloc(f)) < 0)
5559     return -1;
5560   filedup(f);
5561   return fd;
5562 }
5563 
5564 int
5565 sys_read(void)
5566 {
5567   struct file *f;
5568   int n;
5569   char *p;
5570 
5571   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5572     return -1;
5573   return fileread(f, p, n);
5574 }
5575 
5576 int
5577 sys_write(void)
5578 {
5579   struct file *f;
5580   int n;
5581   char *p;
5582 
5583   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
5584     return -1;
5585   return filewrite(f, p, n);
5586 }
5587 
5588 int
5589 sys_close(void)
5590 {
5591   int fd;
5592   struct file *f;
5593 
5594   if(argfd(0, &fd, &f) < 0)
5595     return -1;
5596   proc->ofile[fd] = 0;
5597   fileclose(f);
5598   return 0;
5599 }
5600 int
5601 sys_fstat(void)
5602 {
5603   struct file *f;
5604   struct stat *st;
5605 
5606   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
5607     return -1;
5608   return filestat(f, st);
5609 }
5610 
5611 
5612 int
5613 sys_link(void)
5614 {
5615   char name[DIRSIZ], *new, *old;
5616   struct inode *dp, *ip;
5617 
5618   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
5619     return -1;
5620   if((ip = namei(old)) == 0)
5621     return -1;
5622 
5623   begin_trans();
5624 
5625   ilock(ip);
5626   if(ip->type == T_DIR){
5627     iunlockput(ip);
5628     commit_trans();
5629     return -1;
5630   }
5631 
5632   ip->nlink++;
5633   iupdate(ip);
5634   iunlock(ip);
5635 
5636   if((dp = nameiparent(new, name)) == 0)
5637     goto bad;
5638   ilock(dp);
5639   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
5640     iunlockput(dp);
5641     goto bad;
5642   }
5643   iunlockput(dp);
5644   iput(ip);
5645 
5646   commit_trans();
5647 
5648   return 0;
5649 
5650 bad:
5651   ilock(ip);
5652   ip->nlink--;
5653   iupdate(ip);
5654   iunlockput(ip);
5655   commit_trans();
5656   return -1;
5657 }
5658 
5659 
5660 static int
5661 isdirempty(struct inode *dp)
5662 {
5663   int off;
5664   struct dirent de;
5665 
5666   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
5667     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5668       panic("isdirempty: readi");
5669     if(de.inum != 0)
5670       return 0;
5671   }
5672   return 1;
5673 }
5674 
5675 
5676 
5677 
5678 
5679 
5680 
5681 
5682 
5683 
5684 
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 int
5701 sys_unlink(void)
5702 {
5703   struct inode *ip, *dp;
5704   struct dirent de;
5705   char name[DIRSIZ], *path;
5706   uint off;
5707 
5708   if(argstr(0, &path) < 0)
5709     return -1;
5710   if((dp = nameiparent(path, name)) == 0)
5711     return -1;
5712 
5713   begin_trans();
5714 
5715   ilock(dp);
5716 
5717   
5718   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
5719     goto bad;
5720 
5721   if((ip = dirlookup(dp, name, &off)) == 0)
5722     goto bad;
5723   ilock(ip);
5724 
5725   if(ip->nlink < 1)
5726     panic("unlink: nlink < 1");
5727   if(ip->type == T_DIR && !isdirempty(ip)){
5728     iunlockput(ip);
5729     goto bad;
5730   }
5731 
5732   memset(&de, 0, sizeof(de));
5733   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5734     panic("unlink: writei");
5735   if(ip->type == T_DIR){
5736     dp->nlink--;
5737     iupdate(dp);
5738   }
5739   iunlockput(dp);
5740 
5741   ip->nlink--;
5742   iupdate(ip);
5743   iunlockput(ip);
5744 
5745   commit_trans();
5746 
5747   return 0;
5748 
5749 
5750 bad:
5751   iunlockput(dp);
5752   commit_trans();
5753   return -1;
5754 }
5755 
5756 static struct inode*
5757 create(char *path, short type, short major, short minor)
5758 {
5759   uint off;
5760   struct inode *ip, *dp;
5761   char name[DIRSIZ];
5762 
5763   if((dp = nameiparent(path, name)) == 0)
5764     return 0;
5765   ilock(dp);
5766 
5767   if((ip = dirlookup(dp, name, &off)) != 0){
5768     iunlockput(dp);
5769     ilock(ip);
5770     if(type == T_FILE && ip->type == T_FILE)
5771       return ip;
5772     iunlockput(ip);
5773     return 0;
5774   }
5775 
5776   if((ip = ialloc(dp->dev, type)) == 0)
5777     panic("create: ialloc");
5778 
5779   ilock(ip);
5780   ip->major = major;
5781   ip->minor = minor;
5782   ip->nlink = 1;
5783   iupdate(ip);
5784 
5785   if(type == T_DIR){  
5786     dp->nlink++;  
5787     iupdate(dp);
5788     
5789     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
5790       panic("create dots");
5791   }
5792 
5793   if(dirlink(dp, name, ip->inum) < 0)
5794     panic("create: dirlink");
5795 
5796   iunlockput(dp);
5797 
5798   return ip;
5799 }
5800 int
5801 sys_open(void)
5802 {
5803   char *path;
5804   int fd, omode;
5805   struct file *f;
5806   struct inode *ip;
5807 
5808   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
5809     return -1;
5810   if(omode & O_CREATE){
5811     begin_trans();
5812     ip = create(path, T_FILE, 0, 0);
5813     commit_trans();
5814     if(ip == 0)
5815       return -1;
5816   } else {
5817     if((ip = namei(path)) == 0)
5818       return -1;
5819     ilock(ip);
5820     if(ip->type == T_DIR && omode != O_RDONLY){
5821       iunlockput(ip);
5822       return -1;
5823     }
5824   }
5825 
5826   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
5827     if(f)
5828       fileclose(f);
5829     iunlockput(ip);
5830     return -1;
5831   }
5832   iunlock(ip);
5833 
5834   f->type = FD_INODE;
5835   f->ip = ip;
5836   f->off = 0;
5837   f->readable = !(omode & O_WRONLY);
5838   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
5839   return fd;
5840 }
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 int
5851 sys_mkdir(void)
5852 {
5853   char *path;
5854   struct inode *ip;
5855 
5856   begin_trans();
5857   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
5858     commit_trans();
5859     return -1;
5860   }
5861   iunlockput(ip);
5862   commit_trans();
5863   return 0;
5864 }
5865 
5866 int
5867 sys_mknod(void)
5868 {
5869   struct inode *ip;
5870   char *path;
5871   int len;
5872   int major, minor;
5873 
5874   begin_trans();
5875   if((len=argstr(0, &path)) < 0 ||
5876      argint(1, &major) < 0 ||
5877      argint(2, &minor) < 0 ||
5878      (ip = create(path, T_DEV, major, minor)) == 0){
5879     commit_trans();
5880     return -1;
5881   }
5882   iunlockput(ip);
5883   commit_trans();
5884   return 0;
5885 }
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 int
5901 sys_chdir(void)
5902 {
5903   char *path;
5904   struct inode *ip;
5905 
5906   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0)
5907     return -1;
5908   ilock(ip);
5909   if(ip->type != T_DIR){
5910     iunlockput(ip);
5911     return -1;
5912   }
5913   iunlock(ip);
5914   iput(proc->cwd);
5915   proc->cwd = ip;
5916   return 0;
5917 }
5918 
5919 int
5920 sys_exec(void)
5921 {
5922   char *path, *argv[MAXARG];
5923   int i;
5924   uint uargv, uarg;
5925 
5926   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
5927     return -1;
5928   }
5929   memset(argv, 0, sizeof(argv));
5930   for(i=0;; i++){
5931     if(i >= NELEM(argv))
5932       return -1;
5933     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
5934       return -1;
5935     if(uarg == 0){
5936       argv[i] = 0;
5937       break;
5938     }
5939     if(fetchstr(uarg, &argv[i]) < 0)
5940       return -1;
5941   }
5942   return exec(path, argv);
5943 }
5944 
5945 
5946 
5947 
5948 
5949 
5950 int
5951 sys_pipe(void)
5952 {
5953   int *fd;
5954   struct file *rf, *wf;
5955   int fd0, fd1;
5956 
5957   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
5958     return -1;
5959   if(pipealloc(&rf, &wf) < 0)
5960     return -1;
5961   fd0 = -1;
5962   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
5963     if(fd0 >= 0)
5964       proc->ofile[fd0] = 0;
5965     fileclose(rf);
5966     fileclose(wf);
5967     return -1;
5968   }
5969   fd[0] = fd0;
5970   fd[1] = fd1;
5971   return 0;
5972 }
5973 
5974 
5975 
5976 
5977 
5978 
5979 
5980 
5981 
5982 
5983 
5984 
5985 
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 #include "types.h"
6001 #include "param.h"
6002 #include "memlayout.h"
6003 #include "mmu.h"
6004 #include "proc.h"
6005 #include "defs.h"
6006 #include "x86.h"
6007 #include "elf.h"
6008 
6009 int exec(char *path, char **argv)
6010 {
6011   char *s, *last;
6012   int i, off;
6013   uint argc, sz, sp, ustack[3+MAXARG+1];
6014   struct elfhdr elf;
6015   struct inode *ip;
6016   struct proghdr ph;
6017   pde_t *pgdir, *oldpgdir;
6018 
6019   if((ip = namei(path)) == 0)
6020     return -1;
6021   ilock(ip);
6022   pgdir = 0;
6023 
6024   
6025   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
6026     goto bad;
6027   if(elf.magic != ELF_MAGIC)
6028     goto bad;
6029 
6030   if((pgdir = setupkvm()) == 0)
6031     goto bad;
6032 
6033   
6034   sz = 0;
6035   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6036     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6037       goto bad;
6038     if(ph.type != ELF_PROG_LOAD)
6039       continue;
6040     if(ph.memsz < ph.filesz)
6041       goto bad;
6042     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6043       goto bad;
6044     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6045       goto bad;
6046   }
6047   iunlockput(ip);
6048   ip = 0;
6049 
6050   
6051   
6052   sz = PGROUNDUP(sz);
6053   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6054     goto bad;
6055   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6056   sp = sz;
6057 
6058   
6059   for(argc = 0; argv[argc]; argc++) {
6060     if(argc >= MAXARG)
6061       goto bad;
6062     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6063     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6064       goto bad;
6065     ustack[3+argc] = sp;
6066   }
6067   ustack[3+argc] = 0;
6068 
6069   ustack[0] = 0xffffffff;  
6070   ustack[1] = argc;
6071   ustack[2] = sp - (argc+1)*4;  
6072 
6073   sp -= (3+argc+1) * 4;
6074   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6075     goto bad;
6076 
6077   
6078   for(last=s=path; *s; s++)
6079     if(*s == '/')
6080       last = s+1;
6081   safestrcpy(proc->name, last, sizeof(proc->name));
6082 
6083   
6084   oldpgdir = proc->pgdir;
6085   proc->pgdir = pgdir;
6086   proc->sz = sz;
6087   proc->tf->eip = elf.entry;  
6088   proc->tf->esp = sp;
6089   switchuvm(proc);
6090   freevm(oldpgdir);
6091   return 0;
6092 
6093  bad:
6094   if(pgdir)
6095     freevm(pgdir);
6096   if(ip)
6097     iunlockput(ip);
6098   return -1;
6099 }
6100 #include "types.h"
6101 #include "defs.h"
6102 #include "param.h"
6103 #include "mmu.h"
6104 #include "proc.h"
6105 #include "fs.h"
6106 #include "file.h"
6107 #include "spinlock.h"
6108 
6109 #define PIPESIZE 512
6110 
6111 struct pipe {
6112   struct spinlock lock;
6113   char data[PIPESIZE];
6114   uint nread;     
6115   uint nwrite;    
6116   int readopen;   
6117   int writeopen;  
6118 };
6119 
6120 int
6121 pipealloc(struct file **f0, struct file **f1)
6122 {
6123   struct pipe *p;
6124 
6125   p = 0;
6126   *f0 = *f1 = 0;
6127   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6128     goto bad;
6129   if((p = (struct pipe*)kalloc()) == 0)
6130     goto bad;
6131   p->readopen = 1;
6132   p->writeopen = 1;
6133   p->nwrite = 0;
6134   p->nread = 0;
6135   initlock(&p->lock, "pipe");
6136   (*f0)->type = FD_PIPE;
6137   (*f0)->readable = 1;
6138   (*f0)->writable = 0;
6139   (*f0)->pipe = p;
6140   (*f1)->type = FD_PIPE;
6141   (*f1)->readable = 0;
6142   (*f1)->writable = 1;
6143   (*f1)->pipe = p;
6144   return 0;
6145 
6146 
6147 
6148 
6149 
6150  bad:
6151   if(p)
6152     kfree((char*)p);
6153   if(*f0)
6154     fileclose(*f0);
6155   if(*f1)
6156     fileclose(*f1);
6157   return -1;
6158 }
6159 
6160 void
6161 pipeclose(struct pipe *p, int writable)
6162 {
6163   acquire(&p->lock);
6164   if(writable){
6165     p->writeopen = 0;
6166     wakeup(&p->nread);
6167   } else {
6168     p->readopen = 0;
6169     wakeup(&p->nwrite);
6170   }
6171   if(p->readopen == 0 && p->writeopen == 0){
6172     release(&p->lock);
6173     kfree((char*)p);
6174   } else
6175     release(&p->lock);
6176 }
6177 
6178 
6179 int
6180 pipewrite(struct pipe *p, char *addr, int n)
6181 {
6182   int i;
6183 
6184   acquire(&p->lock);
6185   for(i = 0; i < n; i++){
6186     while(p->nwrite == p->nread + PIPESIZE){  
6187       if(p->readopen == 0 || proc->killed){
6188         release(&p->lock);
6189         return -1;
6190       }
6191       wakeup(&p->nread);
6192       sleep(&p->nwrite, &p->lock);  
6193     }
6194     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6195   }
6196   wakeup(&p->nread);  
6197   release(&p->lock);
6198   return n;
6199 }
6200 int
6201 piperead(struct pipe *p, char *addr, int n)
6202 {
6203   int i;
6204 
6205   acquire(&p->lock);
6206   while(p->nread == p->nwrite && p->writeopen){  
6207     if(proc->killed){
6208       release(&p->lock);
6209       return -1;
6210     }
6211     sleep(&p->nread, &p->lock); 
6212   }
6213   for(i = 0; i < n; i++){  
6214     if(p->nread == p->nwrite)
6215       break;
6216     addr[i] = p->data[p->nread++ % PIPESIZE];
6217   }
6218   wakeup(&p->nwrite);  
6219   release(&p->lock);
6220   return i;
6221 }
6222 
6223 
6224 
6225 
6226 
6227 
6228 
6229 
6230 
6231 
6232 
6233 
6234 
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 #include "types.h"
6251 #include "x86.h"
6252 
6253 void*
6254 memset(void *dst, int c, uint n)
6255 {
6256   if ((int)dst%4 == 0 && n%4 == 0){
6257     c &= 0xFF;
6258     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6259   } else
6260     stosb(dst, c, n);
6261   return dst;
6262 }
6263 
6264 int
6265 memcmp(const void *v1, const void *v2, uint n)
6266 {
6267   const uchar *s1, *s2;
6268 
6269   s1 = v1;
6270   s2 = v2;
6271   while(n-- > 0){
6272     if(*s1 != *s2)
6273       return *s1 - *s2;
6274     s1++, s2++;
6275   }
6276 
6277   return 0;
6278 }
6279 
6280 void*
6281 memmove(void *dst, const void *src, uint n)
6282 {
6283   const char *s;
6284   char *d;
6285 
6286   s = src;
6287   d = dst;
6288   if(s < d && s + n > d){
6289     s += n;
6290     d += n;
6291     while(n-- > 0)
6292       *--d = *--s;
6293   } else
6294     while(n-- > 0)
6295       *d++ = *s++;
6296 
6297   return dst;
6298 }
6299 
6300 
6301 void*
6302 memcpy(void *dst, const void *src, uint n)
6303 {
6304   return memmove(dst, src, n);
6305 }
6306 
6307 int
6308 strncmp(const char *p, const char *q, uint n)
6309 {
6310   while(n > 0 && *p && *p == *q)
6311     n--, p++, q++;
6312   if(n == 0)
6313     return 0;
6314   return (uchar)*p - (uchar)*q;
6315 }
6316 
6317 char*
6318 strncpy(char *s, const char *t, int n)
6319 {
6320   char *os;
6321 
6322   os = s;
6323   while(n-- > 0 && (*s++ = *t++) != 0)
6324     ;
6325   while(n-- > 0)
6326     *s++ = 0;
6327   return os;
6328 }
6329 
6330 
6331 char*
6332 safestrcpy(char *s, const char *t, int n)
6333 {
6334   char *os;
6335 
6336   os = s;
6337   if(n <= 0)
6338     return os;
6339   while(--n > 0 && (*s++ = *t++) != 0)
6340     ;
6341   *s = 0;
6342   return os;
6343 }
6344 
6345 
6346 
6347 
6348 
6349 
6350 int
6351 strlen(const char *s)
6352 {
6353   int n;
6354 
6355   for(n = 0; s[n]; n++)
6356     ;
6357   return n;
6358 }
6359 
6360 
6361 
6362 
6363 
6364 
6365 
6366 
6367 
6368 
6369 
6370 
6371 
6372 
6373 
6374 
6375 
6376 
6377 
6378 
6379 
6380 
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 struct mp {             
6403   uchar signature[4];           
6404   void *physaddr;               
6405   uchar length;                 
6406   uchar specrev;                
6407   uchar checksum;               
6408   uchar type;                   
6409   uchar imcrp;
6410   uchar reserved[3];
6411 };
6412 
6413 struct mpconf {         
6414   uchar signature[4];           
6415   ushort length;                
6416   uchar version;                
6417   uchar checksum;               
6418   uchar product[20];            
6419   uint *oemtable;               
6420   ushort oemlength;             
6421   ushort entry;                 
6422   uint *lapicaddr;              
6423   ushort xlength;               
6424   uchar xchecksum;              
6425   uchar reserved;
6426 };
6427 
6428 struct mpproc {         
6429   uchar type;                   
6430   uchar apicid;                 
6431   uchar version;                
6432   uchar flags;                  
6433     #define MPBOOT 0x02           
6434   uchar signature[4];           
6435   uint feature;                 
6436   uchar reserved[8];
6437 };
6438 
6439 struct mpioapic {       
6440   uchar type;                   
6441   uchar apicno;                 
6442   uchar version;                
6443   uchar flags;                  
6444   uint *addr;                  
6445 };
6446 
6447 
6448 
6449 
6450 
6451 #define MPPROC    0x00  
6452 #define MPBUS     0x01  
6453 #define MPIOAPIC  0x02  
6454 #define MPIOINTR  0x03  
6455 #define MPLINTR   0x04  
6456 
6457 
6458 
6459 
6460 
6461 
6462 
6463 
6464 
6465 
6466 
6467 
6468 
6469 
6470 
6471 
6472 
6473 
6474 
6475 
6476 
6477 
6478 
6479 
6480 
6481 
6482 
6483 
6484 
6485 
6486 
6487 
6488 
6489 
6490 
6491 
6492 
6493 
6494 
6495 
6496 
6497 
6498 
6499 
6500 
6501 
6502 
6503 
6504 #include "types.h"
6505 #include "defs.h"
6506 #include "param.h"
6507 #include "memlayout.h"
6508 #include "mp.h"
6509 #include "x86.h"
6510 #include "mmu.h"
6511 #include "proc.h"
6512 
6513 struct cpu cpus[NCPU];
6514 static struct cpu *bcpu;
6515 int ismp;
6516 int ncpu;
6517 uchar ioapicid;
6518 
6519 int
6520 mpbcpu(void)
6521 {
6522   return bcpu-cpus;
6523 }
6524 
6525 static uchar
6526 sum(uchar *addr, int len)
6527 {
6528   int i, sum;
6529 
6530   sum = 0;
6531   for(i=0; i<len; i++)
6532     sum += addr[i];
6533   return sum;
6534 }
6535 
6536 
6537 static struct mp*
6538 mpsearch1(uint a, int len)
6539 {
6540   uchar *e, *p, *addr;
6541 
6542   addr = p2v(a);
6543   e = addr+len;
6544   for(p = addr; p < e; p += sizeof(struct mp))
6545     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
6546       return (struct mp*)p;
6547   return 0;
6548 }
6549 
6550 
6551 
6552 
6553 
6554 
6555 static struct mp*
6556 mpsearch(void)
6557 {
6558   uchar *bda;
6559   uint p;
6560   struct mp *mp;
6561 
6562   bda = (uchar *) P2V(0x400);
6563   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
6564     if((mp = mpsearch1(p, 1024)))
6565       return mp;
6566   } else {
6567     p = ((bda[0x14]<<8)|bda[0x13])*1024;
6568     if((mp = mpsearch1(p-1024, 1024)))
6569       return mp;
6570   }
6571   return mpsearch1(0xF0000, 0x10000);
6572 }
6573 
6574 
6575 
6576 
6577 
6578 
6579 static struct mpconf*
6580 mpconfig(struct mp **pmp)
6581 {
6582   struct mpconf *conf;
6583   struct mp *mp;
6584 
6585   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
6586     return 0;
6587   conf = (struct mpconf*) p2v((uint) mp->physaddr);
6588   if(memcmp(conf, "PCMP", 4) != 0)
6589     return 0;
6590   if(conf->version != 1 && conf->version != 4)
6591     return 0;
6592   if(sum((uchar*)conf, conf->length) != 0)
6593     return 0;
6594   *pmp = mp;
6595   return conf;
6596 }
6597 
6598 
6599 
6600 void
6601 mpinit(void)
6602 {
6603   uchar *p, *e;
6604   struct mp *mp;
6605   struct mpconf *conf;
6606   struct mpproc *proc;
6607   struct mpioapic *ioapic;
6608 
6609   bcpu = &cpus[0];
6610   if((conf = mpconfig(&mp)) == 0)
6611     return;
6612   ismp = 1;
6613   lapic = (uint*)conf->lapicaddr;
6614   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
6615     switch(*p){
6616     case MPPROC:
6617       proc = (struct mpproc*)p;
6618       if(ncpu != proc->apicid){
6619         cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
6620         ismp = 0;
6621       }
6622       if(proc->flags & MPBOOT)
6623         bcpu = &cpus[ncpu];
6624       cpus[ncpu].id = ncpu;
6625       ncpu++;
6626       p += sizeof(struct mpproc);
6627       continue;
6628     case MPIOAPIC:
6629       ioapic = (struct mpioapic*)p;
6630       ioapicid = ioapic->apicno;
6631       p += sizeof(struct mpioapic);
6632       continue;
6633     case MPBUS:
6634     case MPIOINTR:
6635     case MPLINTR:
6636       p += 8;
6637       continue;
6638     default:
6639       cprintf("mpinit: unknown config type %x\n", *p);
6640       ismp = 0;
6641     }
6642   }
6643   if(!ismp){
6644     
6645     ncpu = 1;
6646     lapic = 0;
6647     ioapicid = 0;
6648     return;
6649   }
6650   if(mp->imcrp){
6651     
6652     
6653     outb(0x22, 0x70);   
6654     outb(0x23, inb(0x23) | 1);  
6655   }
6656 }
6657 
6658 
6659 
6660 
6661 
6662 
6663 
6664 
6665 
6666 
6667 
6668 
6669 
6670 
6671 
6672 
6673 
6674 
6675 
6676 
6677 
6678 
6679 
6680 
6681 
6682 
6683 
6684 
6685 
6686 
6687 
6688 
6689 
6690 
6691 
6692 
6693 
6694 
6695 
6696 
6697 
6698 
6699 
6700 
6701 
6702 
6703 #include "types.h"
6704 #include "defs.h"
6705 #include "memlayout.h"
6706 #include "traps.h"
6707 #include "mmu.h"
6708 #include "x86.h"
6709 
6710 
6711 #define ID      (0x0020/4)   
6712 #define VER     (0x0030/4)   
6713 #define TPR     (0x0080/4)   
6714 #define EOI     (0x00B0/4)   
6715 #define SVR     (0x00F0/4)   
6716   #define ENABLE     0x00000100   
6717 #define ESR     (0x0280/4)   
6718 #define ICRLO   (0x0300/4)   
6719   #define INIT       0x00000500   
6720   #define STARTUP    0x00000600   
6721   #define DELIVS     0x00001000   
6722   #define ASSERT     0x00004000   
6723   #define DEASSERT   0x00000000
6724   #define LEVEL      0x00008000   
6725   #define BCAST      0x00080000   
6726   #define BUSY       0x00001000
6727   #define FIXED      0x00000000
6728 #define ICRHI   (0x0310/4)   
6729 #define TIMER   (0x0320/4)   
6730   #define X1         0x0000000B   
6731   #define PERIODIC   0x00020000   
6732 #define PCINT   (0x0340/4)   
6733 #define LINT0   (0x0350/4)   
6734 #define LINT1   (0x0360/4)   
6735 #define ERROR   (0x0370/4)   
6736   #define MASKED     0x00010000   
6737 #define TICR    (0x0380/4)   
6738 #define TCCR    (0x0390/4)   
6739 #define TDCR    (0x03E0/4)   
6740 
6741 volatile uint *lapic;  
6742 
6743 static void
6744 lapicw(int index, int value)
6745 {
6746   lapic[index] = value;
6747   lapic[ID];  
6748 }
6749 
6750 void
6751 lapicinit(void)
6752 {
6753   if(!lapic)
6754     return;
6755 
6756   
6757   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
6758 
6759   
6760   
6761   
6762   
6763   lapicw(TDCR, X1);
6764   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
6765   lapicw(TICR, 10000000);
6766 
6767   
6768   lapicw(LINT0, MASKED);
6769   lapicw(LINT1, MASKED);
6770 
6771   
6772   
6773   if(((lapic[VER]>>16) & 0xFF) >= 4)
6774     lapicw(PCINT, MASKED);
6775 
6776   
6777   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
6778 
6779   
6780   lapicw(ESR, 0);
6781   lapicw(ESR, 0);
6782 
6783   
6784   lapicw(EOI, 0);
6785 
6786   
6787   lapicw(ICRHI, 0);
6788   lapicw(ICRLO, BCAST | INIT | LEVEL);
6789   while(lapic[ICRLO] & DELIVS)
6790     ;
6791 
6792   
6793   lapicw(TPR, 0);
6794 }
6795 
6796 
6797 
6798 
6799 
6800 int
6801 cpunum(void)
6802 {
6803   
6804   
6805   
6806   
6807   
6808   if(readeflags()&FL_IF){
6809     static int n;
6810     if(n++ == 0)
6811       cprintf("cpu called from %x with interrupts enabled\n",
6812         __builtin_return_address(0));
6813   }
6814 
6815   if(lapic)
6816     return lapic[ID]>>24;
6817   return 0;
6818 }
6819 
6820 
6821 void
6822 lapiceoi(void)
6823 {
6824   if(lapic)
6825     lapicw(EOI, 0);
6826 }
6827 
6828 
6829 
6830 void
6831 microdelay(int us)
6832 {
6833 }
6834 
6835 #define IO_RTC  0x70
6836 
6837 
6838 
6839 void
6840 lapicstartap(uchar apicid, uint addr)
6841 {
6842   int i;
6843   ushort *wrv;
6844 
6845   
6846   
6847   
6848   outb(IO_RTC, 0xF);  
6849   outb(IO_RTC+1, 0x0A);
6850   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
6851   wrv[0] = 0;
6852   wrv[1] = addr >> 4;
6853 
6854   
6855   
6856   lapicw(ICRHI, apicid<<24);
6857   lapicw(ICRLO, INIT | LEVEL | ASSERT);
6858   microdelay(200);
6859   lapicw(ICRLO, INIT | LEVEL);
6860   microdelay(100);    
6861 
6862   
6863   
6864   
6865   
6866   
6867   for(i = 0; i < 2; i++){
6868     lapicw(ICRHI, apicid<<24);
6869     lapicw(ICRLO, STARTUP | (addr>>12));
6870     microdelay(200);
6871   }
6872 }
6873 
6874 
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 
6902 
6903 
6904 #include "types.h"
6905 #include "defs.h"
6906 #include "traps.h"
6907 
6908 #define IOAPIC  0xFEC00000   
6909 
6910 #define REG_ID     0x00  
6911 #define REG_VER    0x01  
6912 #define REG_TABLE  0x10  
6913 
6914 
6915 
6916 
6917 
6918 
6919 #define INT_DISABLED   0x00010000  
6920 #define INT_LEVEL      0x00008000  
6921 #define INT_ACTIVELOW  0x00002000  
6922 #define INT_LOGICAL    0x00000800  
6923 
6924 volatile struct ioapic *ioapic;
6925 
6926 
6927 struct ioapic {
6928   uint reg;
6929   uint pad[3];
6930   uint data;
6931 };
6932 
6933 static uint
6934 ioapicread(int reg)
6935 {
6936   ioapic->reg = reg;
6937   return ioapic->data;
6938 }
6939 
6940 static void
6941 ioapicwrite(int reg, uint data)
6942 {
6943   ioapic->reg = reg;
6944   ioapic->data = data;
6945 }
6946 
6947 
6948 
6949 
6950 void
6951 ioapicinit(void)
6952 {
6953   int i, id, maxintr;
6954 
6955   if(!ismp)
6956     return;
6957 
6958   ioapic = (volatile struct ioapic*)IOAPIC;
6959   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
6960   id = ioapicread(REG_ID) >> 24;
6961   if(id != ioapicid)
6962     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
6963 
6964   
6965   
6966   for(i = 0; i <= maxintr; i++){
6967     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
6968     ioapicwrite(REG_TABLE+2*i+1, 0);
6969   }
6970 }
6971 
6972 void
6973 ioapicenable(int irq, int cpunum)
6974 {
6975   if(!ismp)
6976     return;
6977 
6978   
6979   
6980   
6981   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
6982   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
6983 }
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 
7001 
7002 #include "types.h"
7003 #include "x86.h"
7004 #include "traps.h"
7005 
7006 
7007 #define IO_PIC1         0x20    
7008 #define IO_PIC2         0xA0    
7009 
7010 #define IRQ_SLAVE       2       
7011 
7012 
7013 
7014 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
7015 
7016 static void
7017 picsetmask(ushort mask)
7018 {
7019   irqmask = mask;
7020   outb(IO_PIC1+1, mask);
7021   outb(IO_PIC2+1, mask >> 8);
7022 }
7023 
7024 void
7025 picenable(int irq)
7026 {
7027   picsetmask(irqmask & ~(1<<irq));
7028 }
7029 
7030 
7031 void
7032 picinit(void)
7033 {
7034   
7035   outb(IO_PIC1+1, 0xFF);
7036   outb(IO_PIC2+1, 0xFF);
7037 
7038   
7039 
7040   
7041   
7042   
7043   
7044   outb(IO_PIC1, 0x11);
7045 
7046   
7047   outb(IO_PIC1+1, T_IRQ0);
7048 
7049 
7050   
7051   
7052   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
7053 
7054   
7055   
7056   
7057   
7058   
7059   
7060   
7061   
7062   outb(IO_PIC1+1, 0x3);
7063 
7064   
7065   outb(IO_PIC2, 0x11);                  
7066   outb(IO_PIC2+1, T_IRQ0 + 8);      
7067   outb(IO_PIC2+1, IRQ_SLAVE);           
7068   
7069   
7070   outb(IO_PIC2+1, 0x3);                 
7071 
7072   
7073   
7074   
7075   
7076   outb(IO_PIC1, 0x68);             
7077   outb(IO_PIC1, 0x0a);             
7078 
7079   outb(IO_PIC2, 0x68);             
7080   outb(IO_PIC2, 0x0a);             
7081 
7082   if(irqmask != 0xFFFF)
7083     picsetmask(irqmask);
7084 }
7085 
7086 
7087 
7088 
7089 
7090 
7091 
7092 
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 
7101 
7102 #define KBSTATP         0x64    
7103 #define KBS_DIB         0x01    
7104 #define KBDATAP         0x60    
7105 
7106 #define NO              0
7107 
7108 #define SHIFT           (1<<0)
7109 #define CTL             (1<<1)
7110 #define ALT             (1<<2)
7111 
7112 #define CAPSLOCK        (1<<3)
7113 #define NUMLOCK         (1<<4)
7114 #define SCROLLLOCK      (1<<5)
7115 
7116 #define E0ESC           (1<<6)
7117 
7118 
7119 #define KEY_HOME        0xE0
7120 #define KEY_END         0xE1
7121 #define KEY_UP          0xE2
7122 #define KEY_DN          0xE3
7123 #define KEY_LF          0xE4
7124 #define KEY_RT          0xE5
7125 #define KEY_PGUP        0xE6
7126 #define KEY_PGDN        0xE7
7127 #define KEY_INS         0xE8
7128 #define KEY_DEL         0xE9
7129 
7130 
7131 #define C(x) (x - '@')
7132 
7133 static uchar shiftcode[256] =
7134 {
7135   [0x1D] CTL,
7136   [0x2A] SHIFT,
7137   [0x36] SHIFT,
7138   [0x38] ALT,
7139   [0x9D] CTL,
7140   [0xB8] ALT
7141 };
7142 
7143 static uchar togglecode[256] =
7144 {
7145   [0x3A] CAPSLOCK,
7146   [0x45] NUMLOCK,
7147   [0x46] SCROLLLOCK
7148 };
7149 
7150 static uchar normalmap[256] =
7151 {
7152   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7153   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7154   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7155   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7156   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7157   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7158   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7159   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7160   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7161   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7162   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7163   [0x9C] '\n',      
7164   [0xB5] '/',       
7165   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7166   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7167   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7168   [0x97] KEY_HOME,  [0xCF] KEY_END,
7169   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7170 };
7171 
7172 static uchar shiftmap[256] =
7173 {
7174   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7175   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7176   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7177   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7178   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7179   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7180   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7181   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7182   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7183   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7184   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7185   [0x9C] '\n',      
7186   [0xB5] '/',       
7187   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7188   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7189   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7190   [0x97] KEY_HOME,  [0xCF] KEY_END,
7191   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7192 };
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 static uchar ctlmap[256] =
7201 {
7202   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7203   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7204   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7205   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7206   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7207   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7208   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7209   [0x9C] '\r',      
7210   [0xB5] C('/'),    
7211   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7212   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7213   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7214   [0x97] KEY_HOME,  [0xCF] KEY_END,
7215   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7216 };
7217 
7218 
7219 
7220 
7221 
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 #include "types.h"
7251 #include "x86.h"
7252 #include "defs.h"
7253 #include "kbd.h"
7254 
7255 int
7256 kbdgetc(void)
7257 {
7258   static uint shift;
7259   static uchar *charcode[4] = {
7260     normalmap, shiftmap, ctlmap, ctlmap
7261   };
7262   uint st, data, c;
7263 
7264   st = inb(KBSTATP);
7265   if((st & KBS_DIB) == 0)
7266     return -1;
7267   data = inb(KBDATAP);
7268 
7269   if(data == 0xE0){
7270     shift |= E0ESC;
7271     return 0;
7272   } else if(data & 0x80){
7273     
7274     data = (shift & E0ESC ? data : data & 0x7F);
7275     shift &= ~(shiftcode[data] | E0ESC);
7276     return 0;
7277   } else if(shift & E0ESC){
7278     
7279     data |= 0x80;
7280     shift &= ~E0ESC;
7281   }
7282 
7283   shift |= shiftcode[data];
7284   shift ^= togglecode[data];
7285   c = charcode[shift & (CTL | SHIFT)][data];
7286   if(shift & CAPSLOCK){
7287     if('a' <= c && c <= 'z')
7288       c += 'A' - 'a';
7289     else if('A' <= c && c <= 'Z')
7290       c += 'a' - 'A';
7291   }
7292   return c;
7293 }
7294 
7295 void
7296 kbdintr(void)
7297 {
7298   consoleintr(kbdgetc);
7299 }
7300 
7301 
7302 
7303 
7304 #include "types.h"
7305 #include "defs.h"
7306 #include "param.h"
7307 #include "traps.h"
7308 #include "spinlock.h"
7309 #include "fs.h"
7310 #include "file.h"
7311 #include "memlayout.h"
7312 #include "mmu.h"
7313 #include "proc.h"
7314 #include "x86.h"
7315 
7316 static void consputc(int);
7317 
7318 static int panicked = 0;
7319 
7320 static struct {
7321   struct spinlock lock;
7322   int locking;
7323 } cons;
7324 
7325 static void
7326 printint(int xx, int base, int sign)
7327 {
7328   static char digits[] = "0123456789abcdef";
7329   char buf[16];
7330   int i;
7331   uint x;
7332 
7333   if(sign && (sign = xx < 0))
7334     x = -xx;
7335   else
7336     x = xx;
7337 
7338   i = 0;
7339   do{
7340     buf[i++] = digits[x % base];
7341   }while((x /= base) != 0);
7342 
7343   if(sign)
7344     buf[i++] = '-';
7345 
7346   while(--i >= 0)
7347     consputc(buf[i]);
7348 }
7349 
7350 
7351 void
7352 cprintf(char *fmt, ...)
7353 {
7354   int i, c, locking;
7355   uint *argp;
7356   char *s;
7357 
7358   locking = cons.locking;
7359   if(locking)
7360     acquire(&cons.lock);
7361 
7362   if (fmt == 0)
7363     panic("null fmt");
7364 
7365   argp = (uint*)(void*)(&fmt + 1);
7366   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
7367     if(c != '%'){
7368       consputc(c);
7369       continue;
7370     }
7371     c = fmt[++i] & 0xff;
7372     if(c == 0)
7373       break;
7374     switch(c){
7375     case 'd':
7376       printint(*argp++, 10, 1);
7377       break;
7378     case 'x':
7379     case 'p':
7380       printint(*argp++, 16, 0);
7381       break;
7382     case 's':
7383       if((s = (char*)*argp++) == 0)
7384         s = "(null)";
7385       for(; *s; s++)
7386         consputc(*s);
7387       break;
7388     case '%':
7389       consputc('%');
7390       break;
7391     default:
7392       
7393       consputc('%');
7394       consputc(c);
7395       break;
7396     }
7397   }
7398 
7399 
7400   if(locking)
7401     release(&cons.lock);
7402 }
7403 
7404 void
7405 panic(char *s)
7406 {
7407   int i;
7408   uint pcs[10];
7409 
7410   cli();
7411   cons.locking = 0;
7412   cprintf("cpu%d: panic: ", cpu->id);
7413   cprintf(s);
7414   cprintf("\n");
7415   getcallerpcs(&s, pcs);
7416   for(i=0; i<10; i++)
7417     cprintf(" %p", pcs[i]);
7418   panicked = 1; 
7419   for(;;)
7420     ;
7421 }
7422 
7423 
7424 
7425 
7426 
7427 
7428 
7429 
7430 
7431 
7432 
7433 
7434 
7435 
7436 
7437 
7438 
7439 
7440 
7441 
7442 
7443 
7444 
7445 
7446 
7447 
7448 
7449 
7450 #define BACKSPACE 0x100
7451 #define CRTPORT 0x3d4
7452 static ushort *crt = (ushort*)P2V(0xb8000);  
7453 
7454 static void
7455 cgaputc(int c)
7456 {
7457   int pos;
7458 
7459   
7460   outb(CRTPORT, 14);
7461   pos = inb(CRTPORT+1) << 8;
7462   outb(CRTPORT, 15);
7463   pos |= inb(CRTPORT+1);
7464 
7465   if(c == '\n')
7466     pos += 80 - pos%80;
7467   else if(c == BACKSPACE){
7468     if(pos > 0) --pos;
7469   } else
7470     crt[pos++] = (c&0xff) | 0x0700;  
7471 
7472   if((pos/80) >= 24){  
7473     memmove(crt, crt+80, sizeof(crt[0])*23*80);
7474     pos -= 80;
7475     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
7476   }
7477 
7478   outb(CRTPORT, 14);
7479   outb(CRTPORT+1, pos>>8);
7480   outb(CRTPORT, 15);
7481   outb(CRTPORT+1, pos);
7482   crt[pos] = ' ' | 0x0700;
7483 }
7484 
7485 void
7486 consputc(int c)
7487 {
7488   if(panicked){
7489     cli();
7490     for(;;)
7491       ;
7492   }
7493 
7494   if(c == BACKSPACE){
7495     uartputc('\b'); uartputc(' '); uartputc('\b');
7496   } else
7497     uartputc(c);
7498   cgaputc(c);
7499 }
7500 #define INPUT_BUF 128
7501 struct {
7502   struct spinlock lock;
7503   char buf[INPUT_BUF];
7504   uint r;  
7505   uint w;  
7506   uint e;  
7507 } input;
7508 
7509 #define C(x)  ((x)-'@')  
7510 
7511 void
7512 consoleintr(int (*getc)(void))
7513 {
7514   int c;
7515 
7516   acquire(&input.lock);
7517   while((c = getc()) >= 0){
7518     switch(c){
7519     case C('P'):  
7520       procdump();
7521       break;
7522     case C('U'):  
7523       while(input.e != input.w &&
7524             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
7525         input.e--;
7526         consputc(BACKSPACE);
7527       }
7528       break;
7529     case C('H'): case '\x7f':  
7530       if(input.e != input.w){
7531         input.e--;
7532         consputc(BACKSPACE);
7533       }
7534       break;
7535     default:
7536       if(c != 0 && input.e-input.r < INPUT_BUF){
7537         c = (c == '\r') ? '\n' : c;
7538         input.buf[input.e++ % INPUT_BUF] = c;
7539         consputc(c);
7540         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
7541           input.w = input.e;
7542           wakeup(&input.r);
7543         }
7544       }
7545       break;
7546     }
7547   }
7548   release(&input.lock);
7549 }
7550 int
7551 consoleread(struct inode *ip, char *dst, int n)
7552 {
7553   uint target;
7554   int c;
7555 
7556   iunlock(ip);
7557   target = n;
7558   acquire(&input.lock);
7559   while(n > 0){
7560     while(input.r == input.w){
7561       if(proc->killed){
7562         release(&input.lock);
7563         ilock(ip);
7564         return -1;
7565       }
7566       sleep(&input.r, &input.lock);
7567     }
7568     c = input.buf[input.r++ % INPUT_BUF];
7569     if(c == C('D')){  
7570       if(n < target){
7571         
7572         
7573         input.r--;
7574       }
7575       break;
7576     }
7577     *dst++ = c;
7578     --n;
7579     if(c == '\n')
7580       break;
7581   }
7582   release(&input.lock);
7583   ilock(ip);
7584 
7585   return target - n;
7586 }
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 int
7601 consolewrite(struct inode *ip, char *buf, int n)
7602 {
7603   int i;
7604 
7605   iunlock(ip);
7606   acquire(&cons.lock);
7607   for(i = 0; i < n; i++)
7608     consputc(buf[i] & 0xff);
7609   release(&cons.lock);
7610   ilock(ip);
7611 
7612   return n;
7613 }
7614 
7615 void
7616 consoleinit(void)
7617 {
7618   initlock(&cons.lock, "console");
7619   initlock(&input.lock, "input");
7620 
7621   devsw[CONSOLE].write = consolewrite;
7622   devsw[CONSOLE].read = consoleread;
7623   cons.locking = 1;
7624 
7625   picenable(IRQ_KBD);
7626   ioapicenable(IRQ_KBD, 0);
7627 }
7628 
7629 
7630 
7631 
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 
7653 
7654 #include "types.h"
7655 #include "defs.h"
7656 #include "traps.h"
7657 #include "x86.h"
7658 
7659 #define IO_TIMER1       0x040           
7660 
7661 
7662 
7663 
7664 
7665 #define TIMER_FREQ      1193182
7666 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
7667 
7668 #define TIMER_MODE      (IO_TIMER1 + 3) 
7669 #define TIMER_SEL0      0x00    
7670 #define TIMER_RATEGEN   0x04    
7671 #define TIMER_16BIT     0x30    
7672 
7673 void
7674 timerinit(void)
7675 {
7676   
7677   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
7678   outb(IO_TIMER1, TIMER_DIV(100) % 256);
7679   outb(IO_TIMER1, TIMER_DIV(100) / 256);
7680   picenable(IRQ_TIMER);
7681 }
7682 
7683 
7684 
7685 
7686 
7687 
7688 
7689 
7690 
7691 
7692 
7693 
7694 
7695 
7696 
7697 
7698 
7699 
7700 
7701 
7702 #include "types.h"
7703 #include "defs.h"
7704 #include "param.h"
7705 #include "traps.h"
7706 #include "spinlock.h"
7707 #include "fs.h"
7708 #include "file.h"
7709 #include "mmu.h"
7710 #include "proc.h"
7711 #include "x86.h"
7712 
7713 #define COM1    0x3f8
7714 
7715 static int uart;    
7716 
7717 void
7718 uartinit(void)
7719 {
7720   char *p;
7721 
7722   
7723   outb(COM1+2, 0);
7724 
7725   
7726   outb(COM1+3, 0x80);    
7727   outb(COM1+0, 115200/9600);
7728   outb(COM1+1, 0);
7729   outb(COM1+3, 0x03);    
7730   outb(COM1+4, 0);
7731   outb(COM1+1, 0x01);    
7732 
7733   
7734   if(inb(COM1+5) == 0xFF)
7735     return;
7736   uart = 1;
7737 
7738   
7739   
7740   inb(COM1+2);
7741   inb(COM1+0);
7742   picenable(IRQ_COM1);
7743   ioapicenable(IRQ_COM1, 0);
7744 
7745   
7746   for(p="xv6...\n"; *p; p++)
7747     uartputc(*p);
7748 }
7749 
7750 void
7751 uartputc(int c)
7752 {
7753   int i;
7754 
7755   if(!uart)
7756     return;
7757   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
7758     microdelay(10);
7759   outb(COM1+0, c);
7760 }
7761 
7762 static int
7763 uartgetc(void)
7764 {
7765   if(!uart)
7766     return -1;
7767   if(!(inb(COM1+5) & 0x01))
7768     return -1;
7769   return inb(COM1+0);
7770 }
7771 
7772 void
7773 uartintr(void)
7774 {
7775   consoleintr(uartgetc);
7776 }
7777 
7778 
7779 
7780 
7781 
7782 
7783 
7784 
7785 
7786 
7787 
7788 
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 
7801 
7802 
7803 
7804 
7805 
7806 
7807 .globl start
7808 start:
7809   pushl $argv
7810   pushl $init
7811   pushl $0  
7812   movl $SYS_exec, %eax
7813   int $T_SYSCALL
7814 
7815 
7816 exit:
7817   movl $SYS_exit, %eax
7818   int $T_SYSCALL
7819   jmp exit
7820 
7821 
7822 init:
7823   .string "/init\0"
7824 
7825 
7826 .p2align 2
7827 argv:
7828   .long init
7829   .long 0
7830 
7831 
7832 
7833 
7834 
7835 
7836 
7837 
7838 
7839 
7840 
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 
7853 
7854   .globl name; \
7855   name: \
7856     movl $SYS_ 
7857     int $T_SYSCALL; \
7858     ret
7859 
7860 SYSCALL(fork)
7861 SYSCALL(exit)
7862 SYSCALL(wait)
7863 SYSCALL(pipe)
7864 SYSCALL(read)
7865 SYSCALL(write)
7866 SYSCALL(close)
7867 SYSCALL(kill)
7868 SYSCALL(exec)
7869 SYSCALL(open)
7870 SYSCALL(mknod)
7871 SYSCALL(unlink)
7872 SYSCALL(fstat)
7873 SYSCALL(link)
7874 SYSCALL(mkdir)
7875 SYSCALL(chdir)
7876 SYSCALL(dup)
7877 SYSCALL(getpid)
7878 SYSCALL(sbrk)
7879 SYSCALL(sleep)
7880 SYSCALL(uptime)
7881 SYSCALL(getmysize)
7882 SYSCALL(getkernelstartaddr)
7883 SYSCALL(getkernelendaddr)
7884 SYSCALL(getkernelvariaddr)
7885 SYSCALL(getsystemcalladdr)
7886 SYSCALL(setpriority)
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 
7901 
7902 #include "types.h"
7903 #include "stat.h"
7904 #include "user.h"
7905 #include "fcntl.h"
7906 
7907 char *argv[] = { "sh", 0 };
7908 
7909 int
7910 main(void)
7911 {
7912   int pid, wpid;
7913 
7914   if(open("console", O_RDWR) < 0){
7915     mknod("console", 1, 1);
7916     open("console", O_RDWR);
7917   }
7918   dup(0);  
7919   dup(0);  
7920 
7921   for(;;){
7922     printf(1, "init: starting sh\n");
7923     pid = fork();
7924     if(pid < 0){
7925       printf(1, "init: fork failed\n");
7926       exit();
7927     }
7928     if(pid == 0){
7929       exec("sh", argv);
7930       printf(1, "init: exec sh failed\n");
7931       exit();
7932     }
7933     while((wpid=wait()) >= 0 && wpid != pid)
7934       printf(1, "zombie!\n");
7935   }
7936 }
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 
7951 
7952 #include "types.h"
7953 #include "user.h"
7954 #include "fcntl.h"
7955 
7956 
7957 #define EXEC  1
7958 #define REDIR 2
7959 #define PIPE  3
7960 #define LIST  4
7961 #define BACK  5
7962 
7963 #define MAXARGS 10
7964 
7965 struct cmd {
7966   int type;
7967 };
7968 
7969 struct execcmd {
7970   int type;
7971   char *argv[MAXARGS];
7972   char *eargv[MAXARGS];
7973 };
7974 
7975 struct redircmd {
7976   int type;
7977   struct cmd *cmd;
7978   char *file;
7979   char *efile;
7980   int mode;
7981   int fd;
7982 };
7983 
7984 struct pipecmd {
7985   int type;
7986   struct cmd *left;
7987   struct cmd *right;
7988 };
7989 
7990 struct listcmd {
7991   int type;
7992   struct cmd *left;
7993   struct cmd *right;
7994 };
7995 
7996 struct backcmd {
7997   int type;
7998   struct cmd *cmd;
7999 };
8000 int fork1(void);  
8001 void panic(char*);
8002 struct cmd *parsecmd(char*);
8003 
8004 
8005 void
8006 runcmd(struct cmd *cmd)
8007 {
8008   int p[2];
8009   struct backcmd *bcmd;
8010   struct execcmd *ecmd;
8011   struct listcmd *lcmd;
8012   struct pipecmd *pcmd;
8013   struct redircmd *rcmd;
8014 
8015   if(cmd == 0)
8016     exit();
8017 
8018   switch(cmd->type){
8019   default:
8020     panic("runcmd");
8021 
8022   case EXEC:
8023     ecmd = (struct execcmd*)cmd;
8024     if(ecmd->argv[0] == 0)
8025       exit();
8026     exec(ecmd->argv[0], ecmd->argv);
8027     printf(2, "exec %s failed\n", ecmd->argv[0]);
8028     break;
8029 
8030   case REDIR:
8031     rcmd = (struct redircmd*)cmd;
8032     close(rcmd->fd);
8033     if(open(rcmd->file, rcmd->mode) < 0){
8034       printf(2, "open %s failed\n", rcmd->file);
8035       exit();
8036     }
8037     runcmd(rcmd->cmd);
8038     break;
8039 
8040   case LIST:
8041     lcmd = (struct listcmd*)cmd;
8042     if(fork1() == 0)
8043       runcmd(lcmd->left);
8044     wait();
8045     runcmd(lcmd->right);
8046     break;
8047 
8048 
8049 
8050   case PIPE:
8051     pcmd = (struct pipecmd*)cmd;
8052     if(pipe(p) < 0)
8053       panic("pipe");
8054     if(fork1() == 0){
8055       close(1);
8056       dup(p[1]);
8057       close(p[0]);
8058       close(p[1]);
8059       runcmd(pcmd->left);
8060     }
8061     if(fork1() == 0){
8062       close(0);
8063       dup(p[0]);
8064       close(p[0]);
8065       close(p[1]);
8066       runcmd(pcmd->right);
8067     }
8068     close(p[0]);
8069     close(p[1]);
8070     wait();
8071     wait();
8072     break;
8073 
8074   case BACK:
8075     bcmd = (struct backcmd*)cmd;
8076     if(fork1() == 0)
8077       runcmd(bcmd->cmd);
8078     break;
8079   }
8080   exit();
8081 }
8082 
8083 int
8084 getcmd(char *buf, int nbuf)
8085 {
8086   printf(2, "$ ");
8087   memset(buf, 0, nbuf);
8088   gets(buf, nbuf);
8089   if(buf[0] == 0) 
8090     return -1;
8091   return 0;
8092 }
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 int
8101 main(void)
8102 {
8103   static char buf[100];
8104   int fd;
8105 
8106   
8107   while((fd = open("console", O_RDWR)) >= 0){
8108     if(fd >= 3){
8109       close(fd);
8110       break;
8111     }
8112   }
8113 
8114   
8115   while(getcmd(buf, sizeof(buf)) >= 0){
8116     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8117       
8118       
8119       buf[strlen(buf)-1] = 0;  
8120       if(chdir(buf+3) < 0)
8121         printf(2, "cannot cd %s\n", buf+3);
8122       continue;
8123     }
8124     if(fork1() == 0)
8125       runcmd(parsecmd(buf));
8126     wait();
8127   }
8128   exit();
8129 }
8130 
8131 void
8132 panic(char *s)
8133 {
8134   printf(2, "%s\n", s);
8135   exit();
8136 }
8137 
8138 int
8139 fork1(void)
8140 {
8141   int pid;
8142 
8143   pid = fork();
8144   if(pid == -1)
8145     panic("fork");
8146   return pid;
8147 }
8148 
8149 
8150 
8151 
8152 struct cmd*
8153 execcmd(void)
8154 {
8155   struct execcmd *cmd;
8156 
8157   cmd = malloc(sizeof(*cmd));
8158   memset(cmd, 0, sizeof(*cmd));
8159   cmd->type = EXEC;
8160   return (struct cmd*)cmd;
8161 }
8162 
8163 struct cmd*
8164 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8165 {
8166   struct redircmd *cmd;
8167 
8168   cmd = malloc(sizeof(*cmd));
8169   memset(cmd, 0, sizeof(*cmd));
8170   cmd->type = REDIR;
8171   cmd->cmd = subcmd;
8172   cmd->file = file;
8173   cmd->efile = efile;
8174   cmd->mode = mode;
8175   cmd->fd = fd;
8176   return (struct cmd*)cmd;
8177 }
8178 
8179 struct cmd*
8180 pipecmd(struct cmd *left, struct cmd *right)
8181 {
8182   struct pipecmd *cmd;
8183 
8184   cmd = malloc(sizeof(*cmd));
8185   memset(cmd, 0, sizeof(*cmd));
8186   cmd->type = PIPE;
8187   cmd->left = left;
8188   cmd->right = right;
8189   return (struct cmd*)cmd;
8190 }
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 struct cmd*
8201 listcmd(struct cmd *left, struct cmd *right)
8202 {
8203   struct listcmd *cmd;
8204 
8205   cmd = malloc(sizeof(*cmd));
8206   memset(cmd, 0, sizeof(*cmd));
8207   cmd->type = LIST;
8208   cmd->left = left;
8209   cmd->right = right;
8210   return (struct cmd*)cmd;
8211 }
8212 
8213 struct cmd*
8214 backcmd(struct cmd *subcmd)
8215 {
8216   struct backcmd *cmd;
8217 
8218   cmd = malloc(sizeof(*cmd));
8219   memset(cmd, 0, sizeof(*cmd));
8220   cmd->type = BACK;
8221   cmd->cmd = subcmd;
8222   return (struct cmd*)cmd;
8223 }
8224 
8225 
8226 
8227 
8228 
8229 
8230 
8231 
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 char whitespace[] = " \t\r\n\v";
8253 char symbols[] = "<|>&;()";
8254 
8255 int
8256 gettoken(char **ps, char *es, char **q, char **eq)
8257 {
8258   char *s;
8259   int ret;
8260 
8261   s = *ps;
8262   while(s < es && strchr(whitespace, *s))
8263     s++;
8264   if(q)
8265     *q = s;
8266   ret = *s;
8267   switch(*s){
8268   case 0:
8269     break;
8270   case '|':
8271   case '(':
8272   case ')':
8273   case ';':
8274   case '&':
8275   case '<':
8276     s++;
8277     break;
8278   case '>':
8279     s++;
8280     if(*s == '>'){
8281       ret = '+';
8282       s++;
8283     }
8284     break;
8285   default:
8286     ret = 'a';
8287     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8288       s++;
8289     break;
8290   }
8291   if(eq)
8292     *eq = s;
8293 
8294   while(s < es && strchr(whitespace, *s))
8295     s++;
8296   *ps = s;
8297   return ret;
8298 }
8299 
8300 int
8301 peek(char **ps, char *es, char *toks)
8302 {
8303   char *s;
8304 
8305   s = *ps;
8306   while(s < es && strchr(whitespace, *s))
8307     s++;
8308   *ps = s;
8309   return *s && strchr(toks, *s);
8310 }
8311 
8312 struct cmd *parseline(char**, char*);
8313 struct cmd *parsepipe(char**, char*);
8314 struct cmd *parseexec(char**, char*);
8315 struct cmd *nulterminate(struct cmd*);
8316 
8317 struct cmd*
8318 parsecmd(char *s)
8319 {
8320   char *es;
8321   struct cmd *cmd;
8322 
8323   es = s + strlen(s);
8324   cmd = parseline(&s, es);
8325   peek(&s, es, "");
8326   if(s != es){
8327     printf(2, "leftovers: %s\n", s);
8328     panic("syntax");
8329   }
8330   nulterminate(cmd);
8331   return cmd;
8332 }
8333 
8334 struct cmd*
8335 parseline(char **ps, char *es)
8336 {
8337   struct cmd *cmd;
8338 
8339   cmd = parsepipe(ps, es);
8340   while(peek(ps, es, "&")){
8341     gettoken(ps, es, 0, 0);
8342     cmd = backcmd(cmd);
8343   }
8344   if(peek(ps, es, ";")){
8345     gettoken(ps, es, 0, 0);
8346     cmd = listcmd(cmd, parseline(ps, es));
8347   }
8348   return cmd;
8349 }
8350 struct cmd*
8351 parsepipe(char **ps, char *es)
8352 {
8353   struct cmd *cmd;
8354 
8355   cmd = parseexec(ps, es);
8356   if(peek(ps, es, "|")){
8357     gettoken(ps, es, 0, 0);
8358     cmd = pipecmd(cmd, parsepipe(ps, es));
8359   }
8360   return cmd;
8361 }
8362 
8363 struct cmd*
8364 parseredirs(struct cmd *cmd, char **ps, char *es)
8365 {
8366   int tok;
8367   char *q, *eq;
8368 
8369   while(peek(ps, es, "<>")){
8370     tok = gettoken(ps, es, 0, 0);
8371     if(gettoken(ps, es, &q, &eq) != 'a')
8372       panic("missing file for redirection");
8373     switch(tok){
8374     case '<':
8375       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
8376       break;
8377     case '>':
8378       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8379       break;
8380     case '+':  
8381       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
8382       break;
8383     }
8384   }
8385   return cmd;
8386 }
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 struct cmd*
8401 parseblock(char **ps, char *es)
8402 {
8403   struct cmd *cmd;
8404 
8405   if(!peek(ps, es, "("))
8406     panic("parseblock");
8407   gettoken(ps, es, 0, 0);
8408   cmd = parseline(ps, es);
8409   if(!peek(ps, es, ")"))
8410     panic("syntax - missing )");
8411   gettoken(ps, es, 0, 0);
8412   cmd = parseredirs(cmd, ps, es);
8413   return cmd;
8414 }
8415 
8416 struct cmd*
8417 parseexec(char **ps, char *es)
8418 {
8419   char *q, *eq;
8420   int tok, argc;
8421   struct execcmd *cmd;
8422   struct cmd *ret;
8423 
8424   if(peek(ps, es, "("))
8425     return parseblock(ps, es);
8426 
8427   ret = execcmd();
8428   cmd = (struct execcmd*)ret;
8429 
8430   argc = 0;
8431   ret = parseredirs(ret, ps, es);
8432   while(!peek(ps, es, "|)&;")){
8433     if((tok=gettoken(ps, es, &q, &eq)) == 0)
8434       break;
8435     if(tok != 'a')
8436       panic("syntax");
8437     cmd->argv[argc] = q;
8438     cmd->eargv[argc] = eq;
8439     argc++;
8440     if(argc >= MAXARGS)
8441       panic("too many args");
8442     ret = parseredirs(ret, ps, es);
8443   }
8444   cmd->argv[argc] = 0;
8445   cmd->eargv[argc] = 0;
8446   return ret;
8447 }
8448 
8449 
8450 
8451 struct cmd*
8452 nulterminate(struct cmd *cmd)
8453 {
8454   int i;
8455   struct backcmd *bcmd;
8456   struct execcmd *ecmd;
8457   struct listcmd *lcmd;
8458   struct pipecmd *pcmd;
8459   struct redircmd *rcmd;
8460 
8461   if(cmd == 0)
8462     return 0;
8463 
8464   switch(cmd->type){
8465   case EXEC:
8466     ecmd = (struct execcmd*)cmd;
8467     for(i=0; ecmd->argv[i]; i++)
8468       *ecmd->eargv[i] = 0;
8469     break;
8470 
8471   case REDIR:
8472     rcmd = (struct redircmd*)cmd;
8473     nulterminate(rcmd->cmd);
8474     *rcmd->efile = 0;
8475     break;
8476 
8477   case PIPE:
8478     pcmd = (struct pipecmd*)cmd;
8479     nulterminate(pcmd->left);
8480     nulterminate(pcmd->right);
8481     break;
8482 
8483   case LIST:
8484     lcmd = (struct listcmd*)cmd;
8485     nulterminate(lcmd->left);
8486     nulterminate(lcmd->right);
8487     break;
8488 
8489   case BACK:
8490     bcmd = (struct backcmd*)cmd;
8491     nulterminate(bcmd->cmd);
8492     break;
8493   }
8494   return cmd;
8495 }
8496 
8497 
8498 
8499 
8500 
8501 
8502 
8503 
8504 
8505 
8506 
8507 
8508 
8509 .code16                       
8510 .globl start
8511 start:
8512   cli                         
8513 
8514   
8515   xorw    %ax,%ax             
8516   movw    %ax,%ds             
8517   movw    %ax,%es             
8518   movw    %ax,%ss             
8519 
8520   
8521   
8522 seta20.1:
8523   inb     $0x64,%al               
8524   testb   $0x2,%al
8525   jnz     seta20.1
8526 
8527   movb    $0xd1,%al               
8528   outb    %al,$0x64
8529 
8530 seta20.2:
8531   inb     $0x64,%al               
8532   testb   $0x2,%al
8533   jnz     seta20.2
8534 
8535   movb    $0xdf,%al               
8536   outb    %al,$0x60
8537 
8538   
8539   
8540   
8541   lgdt    gdtdesc
8542   movl    %cr0, %eax
8543   orl     $CR0_PE, %eax
8544   movl    %eax, %cr0
8545 
8546 
8547 
8548 
8549 
8550   
8551   
8552   
8553   ljmp    $(SEG_KCODE<<3), $start32
8554 
8555 .code32  
8556 start32:
8557   
8558   movw    $(SEG_KDATA<<3), %ax    
8559   movw    %ax, %ds                
8560   movw    %ax, %es                
8561   movw    %ax, %ss                
8562   movw    $0, %ax                 
8563   movw    %ax, %fs                
8564   movw    %ax, %gs                
8565 
8566   
8567   movl    $start, %esp
8568   call    bootmain
8569 
8570   
8571   
8572   movw    $0x8a00, %ax            
8573   movw    %ax, %dx
8574   outw    %ax, %dx
8575   movw    $0x8ae0, %ax            
8576   outw    %ax, %dx
8577 spin:
8578   jmp     spin
8579 
8580 
8581 .p2align 2                                
8582 gdt:
8583   SEG_NULLASM                             
8584   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
8585   SEG_ASM(STA_W, 0x0, 0xffffffff)         
8586 
8587 gdtdesc:
8588   .word   (gdtdesc - gdt - 1)             
8589   .long   gdt                             
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 
8601 
8602 
8603 
8604 
8605 
8606 
8607 #include "types.h"
8608 #include "elf.h"
8609 #include "x86.h"
8610 #include "memlayout.h"
8611 
8612 #define SECTSIZE  512
8613 
8614 void readseg(uchar*, uint, uint);
8615 
8616 void
8617 bootmain(void)
8618 {
8619   struct elfhdr *elf;
8620   struct proghdr *ph, *eph;
8621   void (*entry)(void);
8622   uchar* pa;
8623 
8624   elf = (struct elfhdr*)0x10000;  
8625 
8626   
8627   readseg((uchar*)elf, 4096, 0);
8628 
8629   
8630   if(elf->magic != ELF_MAGIC)
8631     return;  
8632 
8633   
8634   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
8635   eph = ph + elf->phnum;
8636   for(; ph < eph; ph++){
8637     pa = (uchar*)ph->paddr;
8638     readseg(pa, ph->filesz, ph->off);
8639     if(ph->memsz > ph->filesz)
8640       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
8641   }
8642 
8643   
8644   
8645   entry = (void(*)(void))(elf->entry);
8646   entry();
8647 }
8648 
8649 
8650 void
8651 waitdisk(void)
8652 {
8653   
8654   while((inb(0x1F7) & 0xC0) != 0x40)
8655     ;
8656 }
8657 
8658 
8659 void
8660 readsect(void *dst, uint offset)
8661 {
8662   
8663   waitdisk();
8664   outb(0x1F2, 1);   
8665   outb(0x1F3, offset);
8666   outb(0x1F4, offset >> 8);
8667   outb(0x1F5, offset >> 16);
8668   outb(0x1F6, (offset >> 24) | 0xE0);
8669   outb(0x1F7, 0x20);  
8670 
8671   
8672   waitdisk();
8673   insl(0x1F0, dst, SECTSIZE/4);
8674 }
8675 
8676 
8677 
8678 void
8679 readseg(uchar* pa, uint count, uint offset)
8680 {
8681   uchar* epa;
8682 
8683   epa = pa + count;
8684 
8685   
8686   pa -= offset % SECTSIZE;
8687 
8688   
8689   offset = (offset / SECTSIZE) + 1;
8690 
8691   
8692   
8693   
8694   for(; pa < epa; pa += SECTSIZE, offset++)
8695     readsect(pa, offset);
8696 }
8697 
8698 
8699 
